/***************************************************************************
*               Generated by StarUML(tm) C++ Add-In                        *
***************************************************************************/
/***************************************************************************
*                                                                          *
*           Institute of Industrial and Control Engineering                *
*                 Technical University of Catalunya                        *
*                        Barcelona, Spain                                  *
*                                                                          *
*                Project Name:       Kautham Planner                       *
*                                                                          *
*     Copyright (C) 2007 - 2009 by Alexander Pérez and Jan Rosell          *
*            alexander.perez@upc.edu and jan.rosell@upc.edu                *
*                                                                          *
*             This is a motion planning tool to be used into               *
*             academic environment and it's provided without               *
*                     any warranty by the authors.                         *
*                                                                          *
*          Alexander Pérez is also with the Escuela Colombiana             *
*          de Ingeniería "Julio Garavito" placed in Bogotá D.C.            *
*             Colombia.  alexander.perez@escuelaing.edu.co                 *
*                                                                          *
***************************************************************************/
/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 ***************************************************************************/
 
 

#include <stdio.h>
#include <libproblem/workspace.h>
#include <libsampling/sampling.h>
#include "localplanner.h"
#include "workspacegridplanner.h"

using namespace libSampling;

namespace libPlanner {
  namespace workspacegridplanner{

    workspacegridPlanner::workspacegridPlanner(SPACETYPE stype, Sample *init, Sample *goal, SampleSet *samples, Sampler *sampler, WorkSpace *ws, LocalPlanner *lcPlan, KthReal ssize):
              Planner(stype, init, goal, samples, sampler, ws, lcPlan, ssize)
	{
		//set intial values
		_obstaclePotential = 10.0;
		_goalPotential = 0.0;

		//set intial values from parent class data
		//_speedFactor = 1;
		//_solved = false;
		//setStepSize(ssize);//also changes stpssize of localplanner
	  
		
		discretizeCspace();
		
	
    }


	workspacegridPlanner::~workspacegridPlanner(){
			
	}

	
		
	void  workspacegridPlanner::readDistances(string file)
	{
		//open file
		FILE *fp;
		fp = fopen(file.c_str(),"rt");
		int nx,ny,nz;

		//read first line and set discrtization steps
		fscanf(fp,"%d %d %d\n",&nx,&ny,&nz);
		_stepsDiscretization.resize(3);
		_stepsDiscretization[0] = nx;
		_stepsDiscretization[1] = ny;
		_stepsDiscretization[2] = nz;

		//read the other lines and load the distance values into the locations vector
		locations.resize(nx*ny*nz);
		unsigned long int i=0;
		unsigned long int id;
		int dist;
		while(!feof(fp))
		{
			fscanf(fp,"%ld %d\n",&id,&dist);
			while(i!=id)
				locations[i++]=-1;//obstacle cell

			locations[i++] = dist;//free cell
		}
		fclose(fp);
	}


	void  workspacegridPlanner::connectgrid(vector<int> &index, int coord_i)
	{
			//for coordinate coord_i, loop for all discretization steps 
			for(int j=0; j<_stepsDiscretization[coord_i]; j++) 
			{
				index[coord_i] = j;
				//if not last coordinate, continue  
				//i.e. by means of a recursive call, all the coordinates are swept
				//until the last coordinate is reached
				if(coord_i != 0) 
				{
					connectgrid(index, coord_i - 1);	
				}
				//if coord_i is the last coordinate, then the indeices of the cell are completed
				//and the edges connecting it t its neighbors are computed
				else
				{
					//find sample label from indices
					int smplabel = 0;
					int coef;
					for(int k=0;k<3;k++){ 
						if(k==0) coef=1;
						else coef = coef * _stepsDiscretization[k-1];
						smplabel += coef*index[k];
					}
					
					//sweep for all directions to find (Manhattan) neighbors
					//neighbors are looked for in the positive drection of the axis
					//i.e. incrementing the index of the current sample
					for(int n=0;n<3;n++)
					{
						//find the label of the neighbor samples from indices
						//a Manhattan neighbor (in the positive direction of an axis)
						//has all the indices equal, minus one that has 
						//the value of the index incremented by one
						int smplabelneighplus = 0;
						bool plusneighexists = true;
						
						for(int k=0;k<3;k++) 
						{
							if(k==0) coef=1;
							else coef = coef*_stepsDiscretization[k-1];
							
							if(k==n) 
							{
								if(index[k]+1 >= _stepsDiscretization[k]) plusneighexists = false;
								smplabelneighplus  += coef*(index[k]+1);
							}
							else
							{
								smplabelneighplus  += coef*index[k];
							}
						}
						//connect samples (if neighbor sample did exist)
						if(plusneighexists==true)
						{
							unsigned long int mm = edges.max_size();
							gridEdge *e;
							
							try{
							//edges are defined as pairs of ints indicating the label of the vertices
							//cout << "smplabel %ld "<<smplabel<<" smplabelneighplus %ld "<<smplabelneighplus<<endl;
							e = new gridEdge(smplabel, smplabelneighplus);
							edges.push_back(e);
							//put a weight to the edge, depending on the collison nature of the cells
							//edges linking  at least one collison sample are weighted -1
							//edges linking free samples are weighted +1

							/*if(locations[smplabel]<0 || locations[smplabelneighplus]<0) 
								weights.push_back(-1.0);
							else 
								weights.push_back(1.0);*/
							}catch(...){
								cout<<"EXCEPTION!"<<endl;
								return;
							}
						}
					}
				}
			}


		}


		
		void  workspacegridPlanner::prunegrid()
		{
			//the filtered graph is obtained using the negative_edge_weight function
			//that filters out edges with a negative weight
			negative_edge_weight<WeightMap> filter(get(edge_weight, *g));

			fg = new filteredGridGraph(*g, filter);
		}

		void  workspacegridPlanner::discretizeCspace()
		{
			//create graph vertices, i.e. read distanceMap and size of grid from file
			readDistances(_wkSpace->getDistanceMapFile());

			//resize graph
			int nx = _stepsDiscretization[0] - 1;
			int ny = _stepsDiscretization[1] - 1;
			int nz = _stepsDiscretization[2] - 1;
			unsigned long int numedges = nx*ny*nz*3+(nx*ny+nx*nz+ny*nz)*2+nx+ny+nz;
			try{
				edges.reserve(numedges);
				//edges.resize(numedges);
			}catch(...){
				cout<<"EXCEPTION resize failed!"<<endl;
			}

			//connect neighbor grid cells
			vector<int> index(3);
			connectgrid(index, 2);

			//create grid as graph (alse sets initial potential values)
			loadGraph();

			//compute the filtered graph that do not consider edges with
			//negative weight (those connecting to a collision vertex)
			prunegrid();
		}


    void workspacegridPlanner::clearGraph()
	{
  		weights.clear();
	    edges.clear();
		_samples->clearNeighs();
	    if(_isGraphSet){
		    locations.clear();
		    delete g;
		    delete fg;
	    }
	    _isGraphSet = false;
		_solved = false;
    }
  
    void workspacegridPlanner::loadGraph()
	{
	    int maxNodes = this->_samples->getSize();
		unsigned int num_edges = edges.size(); 
      
		// create graph with maxNodes nodes
		g = new gridGraph(maxNodes);
		WeightMap weightmap = get(edge_weight, *g);

		//load edges stored in edges array, and put the
		//corresponding weight, stored in the weights array
		for(std::size_t j = 0; j < num_edges; ++j) 
		{
			edge_descriptor e; 
			bool inserted;//when the efge already exisits or is a self-loop
						  //then this flag is set to false and the edge is not inserted 
			tie(e, inserted) = add_edge(edges[j]->first,edges[j]->second, *g);
			if(inserted) weightmap[e] = weights[j];
		}

		

		//set initial potential values with random numbers in the range [0,1]
		//if the cell is free, or to value 10 if it is in collsion
		potmap = get(potential_value_t(), *g);
		
        LCPRNG* rgen = new LCPRNG(15485341);//15485341 is a big prime number
		for(unsigned int i=0;i<num_vertices(*g); i++)
		{
			if(locations[i]>0)//free cell
			{
				setPotential(i, rgen->d_rand()); //random initialization of potential
			}
			else setPotential(i, _obstaclePotential);
		}
		_isGraphSet = true;
	}

	void workspacegridPlanner::computeNF1(gridVertex  vgoal)
	{

		graph_traits<gridGraph>::vertex_iterator vi, vi_end;

		/* Prints adjacencies 

		graph_traits<gridGraph>::adjacency_iterator avi, avi_end;
		for(tie(vi,vi_end)=vertices(*g); vi!=vi_end; ++vi)
		{
			cout<<*vi<< " adjacent to: ";
			for(tie(avi,avi_end)=adjacent_vertices(*vi, *g); avi!=avi_end; ++avi)
			{
				cout<<*avi<<" ,";
			}
			cout<<endl;
		}
		*/

		//initialize potential to -1 and goal to 0
		for(tie(vi,vi_end)=vertices(*g); vi!=vi_end; ++vi)	setPotential(*vi, -1);
		setPotential(vgoal, 0);
		//propagate potential
		breadth_first_search(*fg, vgoal, visitor(bfs_distance_visitor<PotentialMap>(getpotmat())));

		graph_traits<filteredGridGraph>::vertex_iterator i, end;
		for(tie(i,end)=vertices(*fg); i!=end; ++i)
		{
			cout<<"vertex "<< *i<<" dist "<<getPotential(*i)<<endl;
		}
	}

	  

  }
}


