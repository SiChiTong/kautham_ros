/***************************************************************************
*               Generated by StarUML(tm) C++ Add-In                        *
***************************************************************************/
/***************************************************************************
*                                                                          *
*           Institute of Industrial and Control Engineering                *
*                 Technical University of Catalunya                        *
*                        Barcelona, Spain                                  *
*                                                                          *
*                Project Name:       Kautham Planner                       *
*                                                                          *
*     Copyright (C) 2007 - 2009 by Alexander Pérez and Jan Rosell          *
*            alexander.perez@upc.edu and jan.rosell@upc.edu                *
*                                                                          *
*             This is a motion planning tool to be used into               *
*             academic environment and it's provided without               *
*                     any warranty by the authors.                         *
*                                                                          *
*          Alexander Pérez is also with the Escuela Colombiana             *
*          de Ingeniería "Julio Garavito" placed in Bogotá D.C.            *
*             Colombia.  alexander.perez@escuelaing.edu.co                 *
*                                                                          *
***************************************************************************/
/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 ***************************************************************************/
 
 

#include <libproblem/workspace.h>
#include <libsampling/sampling.h>
#include "localplanner.h"
#include "prmObstacleIROS.h"

using namespace libSampling;

namespace libPlanner {
  namespace PRM{
   namespace prmObstaclesIROS{
	//! Constructor
   prmObstaclesPlanner::prmObstaclesPlanner(SPACETYPE stype, Sample *init, Sample *goal, SampleSet *samples, Sampler *sampler, WorkSpace *ws, LocalPlanner *lcPlan, KthReal ssize):
              PRMPlanner(stype, init, goal, samples, sampler, ws, lcPlan, ssize)
	{

	   _guiName = _idName = "PRM Obstacles";

	      _neighThress = 1.5;//0.5//50000.0;
	      _kNeighs = 10;
	      _isGraphSet = false;
		  _maxNumSamples = 200;//1000;
		  _speedFactor = 1;
		  _solved = false;
		  setStepSize(ssize);//also changes stpssize of localplanner
	      _drawnLink = -1; //the path of last link is defaulted
		  _probabilityConnectionIniGoal = 0.1;

	      addParameter("Step Size", ssize);
	      addParameter("Neigh Thresshold", _neighThress);
	      addParameter("Max. Neighs", _kNeighs);
	      addParameter("Max. Samples", _maxNumSamples);
	      addParameter("Speed Factor", _speedFactor);
	      addParameter("Drawn Path Link",_drawnLink);
		  addParameter("P(connect to Ini-Goal)",_probabilityConnectionIniGoal);

		    _labelCC=0;

		    _samples->setTypeSearch(ANNMETHOD);//(BRUTEFORCE);//ANNMETHOD
		    _samples->setWorkspacePtr(_wkSpace);
		    _samples->setANNdatastructures(_kNeighs, _maxNumSamples);

	      for(int i=0; i<_wkSpace->robotsCount();i++)
	        _wkSpace->getRobot(i)->setLinkPathDrawn(_drawnLink);

    }

	//! void destructor
   prmObstaclesPlanner::~prmObstaclesPlanner(){
			
	}
	
	
  	
	//! function to find a solution path
		bool prmObstaclesPlanner::trySolve()
		{
			//cout << "prmObstaclesPlanner::trySolve - now a call to PRMPlanner::trySolve()..."<<endl<<flush;
			//cout << "A bettter alternative is expected to be implemented here..."<<endl<<flush;

			//!function that constructs the PRM and finds a solution path

			  //_samples->setANNdatastructures(_kNeighs, _maxNumSamples);

		      _solved = false;
		      _init->addNeigh(_samples->indexOf(_goal));
		      _goal->addNeigh(_samples->indexOf(_init));
		      int count = 0;

		      //assert(_CrtCheckMemory());

		      if( _isGraphSet ){  //If graph already available
		        //If new configurations have been sampled the graph is rebuild
		        if( _samples->changed())
		        {
		          clearGraph();
		          _samples->findNeighs(_neighThress, _kNeighs);
		          connectSamples();
		          loadGraph();
		        }
		      }
		      //No grah is already avaliable, then build it
		      else
		      {
		        _samples->findNeighs(_neighThress, _kNeighs);
		        connectSamples();
		        loadGraph();
		      }
		      //try to find a path with the samples already available in the sampleSet
		      //If found, smooth it.
		      if( findPath() )
		      {
		        printConnectedComponents();
		        smoothPath();
		        _solved = true;
		        count = _samples->getSize();
		      }
		      //if not found, keep trying until a max number of samples
		      //iteratively growing the PRM
		      else
		      {

		        LCPRNG* rgen = new LCPRNG(15485341);//15485341 is a big prime number
		        count = _samples->getSize();
		        Sample* smp = NULL;
		        count = _samples->getSize();

		        //assert(_CrtCheckMemory());

		        while( count < _maxNumSamples)
		        {
		          smp = NULL;
		          do{
		            if( smp != NULL ) delete smp;
		            smp = _sampler->nextSample();
		            count++;
		          }while(_wkSpace->collisionCheckHard(smp) == true);

		          //assert(_CrtCheckMemory());

		          _samples->add(smp);
		          double r=rgen->d_rand();
		          if(r < _probabilityConnectionIniGoal) connectLastSample(_init);
		          else if(r < 2*_probabilityConnectionIniGoal) connectLastSample(_goal);
		          else connectLastSample();
		          if( findPath() )
		          {
		            printConnectedComponents();
		            smoothPath();
		            cout << "Calls to collision-check = " << count <<endl;
					drawCspace();
		            _solved = true;
		            break;
		          }
		        }
		      }

		      printConnectedComponents();
		      _triedSamples = count;

			  drawCspace();

		      return _solved;
		    }

		}
	  }
    }


