/***************************************************************************
*               Generated by StarUML(tm) C++ Add-In                        *
***************************************************************************/
/***************************************************************************
*                                                                          *
*           Institute of Industrial and Control Engineering                *
*                 Technical University of Catalunya                        *
*                        Barcelona, Spain                                  *
*                                                                          *
*                Project Name:       Kautham Planner                       *
*                                                                          *
*     Copyright (C) 2007 - 2009 by Alexander Pérez and Jan Rosell          *
*            alexander.perez@upc.edu and jan.rosell@upc.edu                *
*                                                                          *
*             This is a motion planning tool to be used into               *
*             academic environment and it's provided without               *
*                     any warranty by the authors.                         *
*                                                                          *
*          Alexander Pérez is also with the Escuela Colombiana             *
*          de Ingeniería "Julio Garavito" placed in Bogotá D.C.            *
*             Colombia.  alexander.perez@escuelaing.edu.co                 *
*                                                                          *
***************************************************************************/
/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 ***************************************************************************/
 

//FIXME: this planner is done for a single TREE robot (associtated to wkSpace->robots[0])

#include <stdio.h>
#include <time.h>
#include "kthquery.h"

#include "prmhandplannerICRAthumb.h"
#include "ML_locplan.h"
 
 namespace libPlanner {
  namespace PRM{
		
	PRMHandPlannerICRAthumb::PRMHandPlannerICRAthumb(SPACETYPE stype, Sample *init, Sample *goal, SampleSet *samples, Sampler *sampler, 
           WorkSpace *ws, LocalPlanner *lcPlan, KthReal ssize, int cloudSize, KthReal cloudRad, int numHC)
      :PRMHandPlanner(stype, init, goal, samples, sampler, ws, lcPlan,  ssize, cloudSize,  cloudRad)
	{
      _idName = "PRM Hand-Thumb ICRA";
			_numberHandConf = numHC;
			addParameter("Ratio Hand/Arm Conf", _numberHandConf);
      addParameter("Neigh Thresshold", -1);

		  _incrementalPMDs = 1;
      addParameter("Incremental PMDs", _incrementalPMDs);

		  ((ManhattanLikeLocalPlanner*) _locPlanner)->setSamplesPtr(_samples);
      ((ManhattanLikeLocalPlanner*) _locPlanner)->setThumbDataPtr(&_vectthl);
	}


	PRMHandPlannerICRAthumb::~PRMHandPlannerICRAthumb(){
			
	}

    bool PRMHandPlannerICRAthumb::setParameters()
	{
      //PRMHandPlanner::setParameters(); //why it is not called?
      try{
        HASH_S_K::iterator it = _parameters.find("Step Size");
        if(it != _parameters.end())
			setStepSize(it->second);//also changes stpssize of localplanner
        else
          return false;

        it = _parameters.find("Speed Factor");
        if(it != _parameters.end())
          _speedFactor = it->second;
        else
          return false;

        it = _parameters.find("Max. Samples");
        if(it != _parameters.end())
          _maxNumSamples = it->second;
        else
          return false;

        //it = _parameters.find("Neigh Thresshold");
        //if(it != _parameters.end())
        //  _neighThress = it->second;
        //else
        //  return false;

        it = _parameters.find("Max. Neighs");
        if(it != _parameters.end())
          _kNeighs = (int)it->second;
        else
          return false;

		it = _parameters.find("Cloud Size");
        if(it != _parameters.end())
          _cloudSize = it->second;
        else
          return false;

        it = _parameters.find("Cloud Radius");
        if(it != _parameters.end())
          _cloudRadius = it->second;
        else
          return false;

        it = _parameters.find("Ratio Hand/Arm Conf");
        if(it != _parameters.end())
          _numberHandConf = it->second;
        else
          return false;

		
        it = _parameters.find("Incremental PMDs");
        if(it != _parameters.end())
          _incrementalPMDs = it->second;
        else
          return false;

      }catch(...){
        return false;
      }
      return true;
    }


	//! finds a random hand configuration for a given arm configuration
	//! returns a range for the thumb joint for which there is no collisions
	//! If randhand is false, the coord vector passed as a parameter is unchanged,
	//! only the thumb limits are computed; then the numPMDs parameter is not used.
	//! if randhand is true, it computes the random conf using a number numPMDs of
	//! PMDs. The value numPMDs = -1 means all of them.
  bool PRMHandPlannerICRAthumb::getHandConfig(vector<KthReal>& coord, thumbLimits *thlimits, bool randhand, int numPMDs)
	{
		vector<KthReal> coordvector;
		KthReal thumb;

		//If random - first find a autocollisionfree sample up to a max of maxtrials
		if(randhand)
		{
			bool autocol;
			int trials=0;
			int maxtrials=10;
			do{
				coordvector.clear();
				//sample the hand coordinates
				if(numPMDs==-1 || numPMDs>(_wkSpace->getDimension()-_wkSpace->getRobot(0)->getTrunk())) 
						numPMDs = _wkSpace->getDimension()-_wkSpace->getRobot(0)->getTrunk();
				int k;
				for(k = 0; k < numPMDs; k++)
				{
					coord[k] = (KthReal)_gen->d_rand();
					coordvector.push_back(coord[k]);
				}
				for(; k < _wkSpace->getDimension()-_wkSpace->getRobot(0)->getTrunk(); k++)
				{
					coord[k] = 0.5;
					coordvector.push_back(coord[k]);
				}
				//load the arm coordinates passed as a parameter
				for(int k =_wkSpace->getDimension()-_wkSpace->getRobot(0)->getTrunk(); k < _wkSpace->getDimension(); k++)
				{
					coordvector.push_back(coord[k]);
				}
				//Set the new sample with the hand-arm coorinates and check for autocollision.				
				_wkSpace->getRobot(0)->control2Pose(coordvector); 
				autocol = _wkSpace->getRobot(0)->autocollision();
				trials++;
			}while(autocol==true && trials<maxtrials);
			if(autocol==true) return false;
		}
		else
		{
			//load the hand-arm coordinates passed as a parameter
			for(int k = 0; k < _wkSpace->getDimension(); k++)
			{
				coordvector.push_back(coord[k]);
			}
			//store the thumb
			thumb = coord[0];
		}

		//Now sweep the thumb (coord[0]) all along its range to find the max free interval
		int N=10;
		bool *collisionfree;
		collisionfree = new bool[N];
		KthReal delta = 1.0/N;
		int ii=0;
		bool autocol;
                Sample *tmpSample = new Sample(_wkSpace->getDimension());

		for(KthReal th=0; th<=1; th=th+delta)
		{
			coordvector[0] = th;
			//Set the new sample with the hand-arm coorinates and check for autocollision.				
			_wkSpace->getRobot(0)->control2Pose(coordvector); 
			autocol = _wkSpace->getRobot(0)->autocollision();
			if(autocol==true) 
			{
				collisionfree[ii]=false;
				ii=ii+1;
				continue;
			}

			//Set the new sample with the hand-arm coorinates and collision-check.
			coord[0] = th;
			tmpSample->setCoords(coord);
			if( !_wkSpace->collisionCheck(tmpSample))
			{
				collisionfree[ii]=true;
			}
			else collisionfree[ii]=false;
			ii=ii+1;
		}

		int setini=0;
		thumbLimits *thl;
		vector<thumbLimits*> vl;
		for(int i=0; i<=N; i++)
		{
			if(collisionfree[i]==true)
			{
				if(setini==0)//interval not yet opened
				{
					thl = new thumbLimits;
					thl->first = (KthReal)i/N;
					setini=1;
				}
			}
			else if(setini==1)
			{
				thl->second = (KthReal)i/N;
				vl.push_back(thl);
				setini=0;
			}
		}
		if(setini==1)//interval not yet closed
		{
				thl->second = 1;
				vl.push_back(thl);
				setini=0;
		}

		if(vl.size()==0) return false;
		else
		{
			KthReal thsize=0;
			int selected;
			for(int j=0; j<vl.size(); j++)
			{
				if(thsize < (vl[j]->second - vl[j]->first))
				{
					thsize = vl[j]->second - vl[j]->first;
					selected = j;
				};
			}

			if(randhand) coord[0] = vl[selected]->first + (vl[selected]->second - vl[selected]->first) / 2;
			else coord[0] = thumb; //restore the original value

			thlimits->first = vl[selected]->first;
			thlimits->second = vl[selected]->second;
			vl.clear();
			delete collisionfree;
			return true;
		}
	}

	void PRMHandPlannerICRAthumb::pruneNeighs(Sample* smp)
	{
		int n = _samples->indexOf(smp);
		KthReal min = _vectthl[n]->first;
		KthReal max = _vectthl[n]->second;
		vector<unsigned int>* v = smp->getNeighs();

		for(unsigned int j=0; j < v->size(); j++)
		{
			n = smp->getNeighs()->at(j);
			KthReal minj = _vectthl[n]->first;
			KthReal maxj = _vectthl[n]->second;
			if(maxj<min || max<minj)
			{
				//not overlapped -  remove j from vector of neighs
				v->erase(v->begin()+j);
			}
		}
	}


	
 	void PRMHandPlannerICRAthumb::computeMaxSteps(KthReal radius, int *bits, int *steps)
	{
		//compute the number of steps to interpolate the straight segment of the arm connecting cini and cgoal
	  //we assume each arm configuration will be associated with "_numberHandConf" hand configurations
	  double dist=0; //distance from cini to cgoal (in the arm cspace)
	  for(int i =_wkSpace->getDimension()-_wkSpace->getRobot(0)->getTrunk(); i < _wkSpace->getDimension(); i++)	
	  {
			double s = goalSamp()->getCoords()[i] - initSamp()->getCoords()[i];
			dist += (s*s);
	  }
	  dist = sqrt(dist);
      int maxsteps = (int)(dist/(double)(radius)) + 2; 
	  

	  //find how many bits are needed to code the maxsteps
	  int b= ceil(log10( (double) maxsteps) / log10( 2.0 ));
	  *steps = (0x01<<b);
	  *bits = b;

	  cout << "MAXSTEPS = " << *steps << " DIST = " << dist << " cloudRadius = " << radius << endl;
	  cout << flush;
	  

	}



 	bool PRMHandPlannerICRAthumb::trySolve()
	{
		int twoPMDs=0;//for statistic results of number of PMDs used
		int threePMDs=0;
		int fourPMDs=0;
		int fivePMDs=0;
    _solved = false;

    if(_samples->changed()){
			PRMPlanner::clearGraph(); //also puts _solved to false;
		}

		//if( findQuery() {
		//	cout << "PATH ALREADY SOLVED"<<endl;
		//	return true;
		//}
		
		cout<<"ENTERING TRYSOLVE!!!"<<endl;
    clock_t entertime = clock();
		
		double radius;

    std::vector<KthReal> stps(wkSpace()->getDimension());
    std::vector<KthReal> coord(wkSpace()->getDimension());
    Sample *tmpSample;
	  vector<KthReal> coordvector;
	  int trials, maxtrials;

	
	  //Create graph with initial and goal sample
    if( !_isGraphSet ) {
      _samples->findBFNeighs(_neighThress, _kNeighs);

      thumbLimits *thlinit = new thumbLimits;
      vector<KthReal>& coordinit = initSamp()->getCoords();

      if(getHandConfig(coordinit, thlinit, false,0))
        _vectthl.push_back(thlinit);

      thumbLimits *thlgoal = new thumbLimits;
      vector<KthReal>& coordgoal = goalSamp()->getCoords();

      if(getHandConfig(coordgoal, thlgoal, false,0))
        _vectthl.push_back(thlgoal);

      if(_vectthl.size()<2){
        cout <<"INIT/GOAL thumb ranges failed"<<endl;
        _vectthl.clear();
        return _solved=false;
      }

      pruneNeighs(_samples->getSampleAt(0) );
      pruneNeighs(_samples->getSampleAt(1) );
      connectSamples();
      PRMPlanner::loadGraph();
      if(PRMPlanner::findPath())
        return _solved = true;
	  }

  
	  //maxsteps is sweeped following the Van Der Corput sequence
	  //index is the index of the Van der Corput sequence, using b bites the sequence has 2^b elements
	  //dj is the bit j of the binary representation of the index
	  //rj are the elements of the sequence
	  int maxsteps;
	  int b;
	  int index;
	  double rj;
	  int dj;

    int found = 0;
	  int n=0; // counter of samples
	  int p=0;//counter of times the arm has swept all its maxsteps steps.
	  double minRJ;
	  double maxRJ;
	  int maxjh=0;//max counter of trials to obtaine a valid hand-arm config per step i

    // ALEX: This cicle is used to try to generate more samples near to the goal region.
    do{
      getSampleInGoalRegion();
      n++;
    }while(_samples->getSize() < 5 && _maxNumSamples/n > 3);

      
	  //compute the stepsize in each robot joint
	  //(FIXME: the last variables correspond to those of the arm because it is defines in this way in the 
	  //robot file, thus the following loop for the joints of the trunk go from n-trunk to n)
      for(int k =_wkSpace->getDimension()-_wkSpace->getRobot(0)->getTrunk(); k < _wkSpace->getDimension(); k++) 
			stps[k] = (goalSamp()->getCoords()[k] - initSamp()->getCoords()[k]); // this is the delta step for each dimension
			
	  //Sampling the clouds...
	  //Iterate through all the steps of the straighth path, centering a cloud of robot configurations
	  //around each. Loop by setting a new sample per step until the clouds are done.
      tmpSample = new Sample(_wkSpace->getDimension());


	  do{
			vector<Sample*>::iterator itSam;
			bool autocol;//flag to test autocollisions
	
			minRJ=0.0;
			maxRJ=1.0;

			p++;
			//set the radius of the sphere where to sample randomly
			//the radius increases as new passes are required
			radius = _cloudRadius * p;
			computeMaxSteps(radius, &b, &maxsteps);
			//cout << "Pass number = "<< p << " cloudradius = " << radius<< endl<<flush;

			//loop for the arm configurations, swept using the vanderCorput sequence
			for(int i=0; i <= maxsteps; i++){

				//Set the coordinates of the robot joints 
				//Randomly set the coordinates of the robot joints at a autocollision-free conf

				//maxsteps is sweeped following the Van Der Corput sequence
			    //dj is the bit j of the binary representation of the index
			    //rj are the elements of the sequence
				//rj = 1, 0, 0.5, 0.25, 0.75, ...
        if(i==0)
          rj=1;
				else{
					index = i-1;
					rj=0;
					for(int jj = 0; jj < b ; jj++){
						dj = (index >> jj) & 0x01;
						rj += ((double)dj /  (double)(0x01<<(jj+1)) );
					}
				}
				//end computing the vandercorput step index


				//filter
				//cout << "------------ rj = " << rj << " minRJ = "<<minRJ <<" maxRJ = "<<maxRJ<<endl << flush;
        if(rj<minRJ)
          continue;
        else if(rj>maxRJ)
          continue;
				//printConnectedComponents();
				//endfilter


				//start loop of arm	configurations
				for(int j=0; j< _cloudSize; j++)
				{
					//compute the joint values for the arm
					trials=0;
					maxtrials=10;
					do{
						coordvector.clear();
						for(int k = 0; k < _wkSpace->getDimension()-_wkSpace->getRobot(0)->getTrunk(); k++)
						{
							coord[k] = 0.5;//DUMMY values - overwritten in getHandConfig function
							coordvector.push_back(coord[k]); //dummy values - not used in call to autocollision with parameter 1
						}

						for(int k =_wkSpace->getDimension()-_wkSpace->getRobot(0)->getTrunk(); k < _wkSpace->getDimension(); k++)
						{
							coord[k] = initSamp()->getCoords()[k] + rj*stps[k] + radius*(2*(KthReal)_gen->d_rand()-1);
							coordvector.push_back(coord[k]);
						}

						//Set the new sample with the hand-arm coorinates and check for autocollision.
						_wkSpace->getRobot(0)->control2Pose(coordvector); 
						autocol = _wkSpace->getRobot(0)->autocollision(1);//only test for the trunk
						trials++;
					}while(autocol==true && trials<maxtrials);

          if(autocol == true)
            continue;

					//loop for several hand conf per arm conf in the cloud
					int numPMDs=1;
					for(int h=0; h< _numberHandConf; h++)
					{
						thumbLimits *thl = new thumbLimits;
						
						if(_incrementalPMDs==0) numPMDs = -1; //all
						else numPMDs++; //starts with two PMDs (the thumb and the first PMD obtained by PCA)

						if( getHandConfig(coord, thl, true, numPMDs) )
						{
							tmpSample->setCoords(coord);
							if( !_wkSpace->collisionCheck(tmpSample))
							{ 	
								_vectthl.push_back(thl);
								_samples->add(tmpSample);
                tmpSample = new Sample(_wkSpace->getDimension());
							
								//add to graph
								if(rj==0) PRMPlanner::connectLastSample( initSamp() );
								else if (rj==1.0) PRMPlanner::connectLastSample( goalSamp() );
								else PRMPlanner::connectLastSample( );

								int lastComponent = _samples->getSampleAt(_samples->getSize() - 1)->getConnectedComponent();

								//already found hand-arm conf for step i
								if(j!=0 || h!=0){
									int m=(j+1)*_numberHandConf + (h+1);
									if(m>maxjh) maxjh=m;
								}
								h =  _numberHandConf; //break for h
								j = _cloudSize;		  //break for j
								if(goalSamp()->getConnectedComponent() == initSamp()->getConnectedComponent()) 
								{
									i = maxsteps;		  //break for i
									found = 1;			//end while loop
								}
								
								else if(lastComponent == initSamp()->getConnectedComponent()) 
								{
									minRJ = rj;
								}
								else if(lastComponent == goalSamp()->getConnectedComponent()) 
								{
									maxRJ = rj;
								}							
								//to store results:
								if(numPMDs==2) twoPMDs++;
								else if(numPMDs==3) threePMDs++;
								else if(numPMDs==4) fourPMDs++;
								else if(numPMDs>4) fivePMDs++;
							}
						}
						else delete thl;

						//n is the counter of samples.
            n = n++;
            if(n>= _maxNumSamples)
						{	
							h =  _numberHandConf; //break for h
							j = _cloudSize;		  //break for j
							i = maxsteps;		  //break for i
						}
					}
				}
			}

      if(PRMPlanner::findPath()){
        _solved = true;
				printConnectedComponents();
				cout << "PRM Nodes = " << _samples->getSize() << endl;
				cout << "Number sampled configurations = " << n << endl;
				
				clock_t finaltime = clock();
				cout<<"TIME TO COMPUTE THE PATH = "<<(double)(finaltime-entertime)/CLOCKS_PER_SEC<<endl;
				PRMPlanner::smoothPath();

				clock_t finalsmoothtime = clock();
				cout<<"TIME TO SMOOTH THE PATH = "<<(double)(finalsmoothtime - finaltime)/CLOCKS_PER_SEC<<endl;

				
				cout << "Number of passes = " << p << " radius = " << radius<< endl;
				cout << "maxjh = " <<maxjh<< " minRJ = "<<minRJ <<" maxRJ = "<<maxRJ<<endl << flush;
				cout << "2PMDs = " <<twoPMDs<< " 3PMDs = "<<threePMDs <<" 4PMDs = "<<fourPMDs<<" 5PMDs = "<<fivePMDs<<endl<<flush;
				
        _solved = true;
        _triedSamples = n;
        _totalTime = (KthReal)(finaltime - entertime)/CLOCKS_PER_SEC ;
        _smoothTime = (KthReal)(finalsmoothtime - finaltime)/CLOCKS_PER_SEC ;
        return _solved;
			}
    }while(n < _maxNumSamples && found==0);


	  /*
	  //Last chance - sample more at the goal...
	  maxtrials = 100; //_numberHandConf * _cloudSize;
	  trials = 0;

	  while(trials<maxtrials && goalSamp()->getConnectedComponent() != initSamp()->getConnectedComponent())
	  {
			trials++;
			
			if(getSampleInGoalRegion() == false) continue;
			
			//add to graph
			connectLastSample( goalSamp() );

			if(PRMPlanner::findPath())
			{
				cout << "PRM Free Nodes = " << _samples->getSize() << endl;
				cout<<"PATH POUND"<<endl;
				printConnectedComponents();
				
				clock_t finaltime = clock();
				cout<<"TIME TO COMPUTE THE PATH = "<<(double)(finaltime-entertime)/CLOCKS_PER_SEC<<endl;
				
				PRMPlanner::smoothPath();
				
				clock_t finalsmoothtime = clock();
				cout<<"TIME TO SMOOTH THE PATH = "<<(double)(finalsmoothtime - finaltime)/CLOCKS_PER_SEC<<endl;
				return true;
			}
	  }
	  */
	  

	  cout << "PRM Free Nodes = " << _samples->getSize() << endl;
	  cout<<"PATH NOT FOUND"<<endl;
	  printConnectedComponents();
	  
	  clock_t finaltime = clock();
	  cout<<"ELAPSED TIME = "<<(double)(finaltime-entertime)/CLOCKS_PER_SEC<<endl;

	  cout << "Number sampled configurations = " << n << endl;
	  cout << "Number of passes = " << p << " radius = " << radius<< endl;
	  cout << "maxjh = " <<maxjh<< " minRJ = "<<minRJ <<" maxRJ = "<<maxRJ<<endl << flush;
	  cout << "2PMDs = " <<twoPMDs<< " 3PMDs = "<<threePMDs <<" 4PMDs = "<<fourPMDs<<" 5PMDs = "<<fivePMDs<<endl<<flush;

    _solved = false;
    _triedSamples = n;
    _totalTime = (KthReal)(finaltime-entertime)/CLOCKS_PER_SEC;
    _smoothTime = 0. ;
    return _solved;
    }


   //!resample around the goal configuration
	//!reimplemented
    bool PRMHandPlannerICRAthumb::getSampleInGoalRegion(){
      double radius = _cloudRadius / 2;
	    vector<KthReal> coordvector;
	    int trials, maxtrials;
      vector<KthReal> coord(_wkSpace->getDimension());
      vector<KthReal> coordarm(_wkSpace->getDimension());
      bool autocol;//flag to test autocollisions
      Sample *tmpSample;
		
      tmpSample = new Sample(_wkSpace->getDimension());

		//Set the coordinates of the robot joints 
		//Randomly set the coordinates of the robot joints at a autocollision-free conf
		trials=0;
		maxtrials=10;
		do{
			coordvector.clear();
			for(int k = 0; k < _wkSpace->getDimension()-_wkSpace->getRobot(0)->getTrunk(); k++)
			{
				coordvector.push_back(0.0); //dummy values - not used in call to autocollision with parameter 1
			}
			for(int k =_wkSpace->getDimension()-_wkSpace->getRobot(0)->getTrunk(); k < _wkSpace->getDimension(); k++)
			{
				coordarm[k] = goalSamp()->getCoords()[k] + radius*(2*(KthReal)_gen->d_rand()-1);
				coordvector.push_back(coordarm[k]);
			}
			//Set the new sample with the hand-arm coorinates and check for autocollision.
			_wkSpace->getRobot(0)->control2Pose(coordvector); 
			autocol = _wkSpace->getRobot(0)->autocollision(1);//only test for the trunk
			trials++;
		}while(autocol==true && trials<maxtrials);

		if(autocol==true) return false;
		
		//Randomly set the coordinates of the hand joints at a autocollision-free conf
		thumbLimits *thl = new thumbLimits;
		if( getHandConfig(coord, thl, true, -1) )
		{
			tmpSample->setCoords(coord);
			if( !_wkSpace->collisionCheck(tmpSample))
			{ 	
				_vectthl.push_back(thl);
				_samples->add(tmpSample);
				return true;
			}
			else 
			{
				delete thl;
				return false;
			}
		}
	}


    void PRMHandPlannerICRAthumb::moveAlongPath(unsigned int step)
	{
      if(_solved){
        if(_simulationPath.size() == 0 ){ // Then calculate the simulation path based on stepsize

          unsigned int maxsteps = 0;
          Sample* tmpSam;
          KthReal dist = (KthReal)0.0;
          std::vector<KthReal> steps(wkSpace()->getDimension());
          std::vector<KthReal> tmpCoords(wkSpace()->getDimension());
		  
          Sample *init, *goal, *init2, *goal2;
          KthReal initthumb;
		  		  
          for(unsigned i = 0; i < _path.size()-1; i++){
		    //compute intermediate points
				init = _path[i];
				goal = _path[i+1];
				if(i==0) initthumb = _path[0]->getCoords()[0];
				else initthumb = goal2->getCoords()[0];

				_locPlanner->setInitSamp(_path[i]);
				_locPlanner->setGoalSamp(_path[i+1]);
				((ManhattanLikeLocalPlanner*) _locPlanner)->setIntermediateConfs();
				init2 = ((ManhattanLikeLocalPlanner*) _locPlanner)->initSamp2();
				goal2 = ((ManhattanLikeLocalPlanner*) _locPlanner)->goalSamp2();

			//First move along thumb 
				//cout<<"move thumb " <<i<<endl<<flush;
				dist = (KthReal)0.0;
        for(int k = 1; k < wkSpace()->getDimension(); k++){
					steps[k] = init2->getCoords()[k] - init->getCoords()[k];
					dist += (steps[k]*steps[k]);
				}
				steps[0] = init2->getCoords()[0] - initthumb;
				dist += (steps[0]*steps[0]);

				dist = sqrt(dist);
				maxsteps = (dist/_stepSize) + 2; //the 2 is necessary to always reduce the distance...???

        for(int k = 0; k < wkSpace()->getDimension(); k++)
					steps[k] = steps[k]/maxsteps;

				for(unsigned int j = 0; j < maxsteps; j++)
				{
					//thumb
					tmpCoords[0] = initthumb + j*steps[0];
					//PMDs and arm
          for(int k = 1; k < wkSpace()->getDimension(); k++)
						tmpCoords[k] = init->getCoords()[k] + j*steps[k];
              
                                        tmpSam = new Sample(_wkSpace->getDimension());
					tmpSam->setCoords(tmpCoords);
					_simulationPath.push_back(tmpSam);
				}

		    //Now move along the PMDs
				//cout<<"move PMD " <<i<<endl<<flush;
				dist = (KthReal)0.0;
        for(int k = 0; k < wkSpace()->getDimension(); k++){
					steps[k] = goal2->getCoords()[k] - init2->getCoords()[k];
					dist += (steps[k]*steps[k]);
				}
				dist = sqrt(dist);
				maxsteps = (dist/_stepSize) + 2; //the 2 is necessary to always reduce the distance...???
			      
        for(int k = 0; k < wkSpace()->getDimension(); k++)
					steps[k] = steps[k]/maxsteps;
            
				for(unsigned int j = 0; j < maxsteps; j++){
          for(int k = 0; k < wkSpace()->getDimension(); k++)
						tmpCoords[k] = init2->getCoords()[k] + j*steps[k];
              
                                        tmpSam = new Sample(_wkSpace->getDimension());
					tmpSam->setCoords(tmpCoords);
					_simulationPath.push_back(tmpSam);
				}
			
			//Last move again along thumb if its the final path segment
				if(i == _path.size()-2)
				{
					//cout<<"move last thumb " <<i<<endl<<flush;
					steps[0] = goal->getCoords()[0] - goal2->getCoords()[0];
					if(steps[0] > 0) dist = steps[0];
					else dist = -steps[0];

					maxsteps = (dist/_stepSize) + 2; //the 2 is necessary to always reduce the distance...???
			      
					steps[0] = steps[0]/maxsteps;
            

					for(unsigned int j = 0; j<maxsteps; j++){
				
						tmpCoords[0] = goal2->getCoords()[0] + j*steps[0];

            for(int k = 1; k < wkSpace()->getDimension(); k++)
							tmpCoords[k] = goal->getCoords()[k];
              
                                                tmpSam = new Sample(_wkSpace->getDimension());
						tmpSam->setCoords(tmpCoords);
						_simulationPath.push_back(tmpSam);
					}
					/*
					cout<<"last tmpSmp: ";
					for(int k = 0; k < Sample::DIM; k++)
							cout<<", "<< tmpSam->getCoords()[k];
					cout<<endl<<flush;
					cout<<"GOAL Smp: ";
					for(int k = 0; k < Sample::DIM; k++)
							cout<<", "<< _goal->getCoords()[k];
					cout<<endl<<flush;
					*/
				}

		  }
//          delete []steps;
//          delete []tmpCoords;
        }

        step = step % _simulationPath.size();
		_wkSpace->moveRobotsTo(_simulationPath[step]);
      }
    }


    void PRMHandPlannerICRAthumb::writeFiles(FILE *fpr, FILE *fph, RobConf* joints)
	{
		//write arm coordinates
		int j;
		for(j =0; j < 6; j++)
      fprintf(fpr,"%.2f ",joints->getRn().getCoordinate(j)*180.0/PI);
		fprintf(fpr,"\n");

		//write hand coordinates
    for(; j < joints->getRn().getDim(); j++)
		{
			if(j==6 || j==11 || j==15 || j==19 || j==23) continue;
      fprintf(fph,"%.2f ",joints->getRn().getCoordinate(j)*180.0/PI);
		}
		fprintf(fph,"\n");
	}


//    void PRMHandPlannerICRAthumb::setIniGoal()
//	{
//		  if(_wkSpace->getDimension()==11)
//		  {
//		    cout << "Setting initial and goal configurations (5 PMDs assumed)"<<endl<<flush;
			
//      std::vector<KthReal> c(11);
//			//c[0] = 0.366;
//			//c[1] = 0.588;
//			//c[2] = 0.0;
//			//c[3] = 0.392;
//			//c[4] = 0.773;
//			//c[5] = 0.258;
//			//c[6] = 0.515;
//			//c[7] = 0.856;
//			//c[8] = 0.5;
//			//c[9] = 0.392;
//			//c[10] = 0.737;

//      // sceneRevistaICRA09-exhaustive.iv
//      c[0] = 0.221;
//			c[1] = 0.492;
//			c[2] = 0.0;
//			c[3] = 0.682;
//			c[4] = 0.513;
//			c[5] = 0.291;
//			c[6] = 0.574;
//			c[7] = 0.756;
//			c[8] = 0.621;
//			c[9] = 0.427;
//			c[10] = 0.618;

//   //   // sceneRevistaICRA09-other.iv
//   //   c[0] = 0.574;
//			//c[1] = 0.226;
//			//c[2] = 0.041;
//			//c[3] = 1.0;
//			//c[4] = 1.0;
//			//c[5] = 0.271;
//			//c[6] = 0.544;
//			//c[7] = 0.718;
//			//c[8] = 0.467;
//			//c[9] = 0.676;
//			//c[10] = 0.708;
//      _goal = new Sample(_wkSpace->getDimension());
//			goalSamp()->setCoords(c);
//			_samples->add(_goal);

//			/*
//			vector<KthReal> parametersCGOAL;
//			vector<KthReal> controlsCGOAL;
//			for(int i=0; i<11;i++) controlsCGOAL.push_back(c[i]);
//			_wkSpace->getRobot(0)->control2Parameters(controlsCGOAL,parametersCGOAL);
//			cout<<"CONTROLS CGOAL";
//			for(int i=0; i<controlsCGOAL.size();i++)
//			{
//				cout << ", "<< controlsCGOAL[i];
//			}
//			cout<<flush<<endl;
//			cout<<"PARAMETERS CGOAL";
//			for(int i=0; i<parametersCGOAL.size();i++)
//			{
//				cout << ", "<< parametersCGOAL[i];
//			}
//			cout<<flush<<endl;
//			*/

//			//c[0] = 1.0;
//			//c[1] = 0.5;
//			//c[2] = 0.0;
//			//c[3] = 0.5;
//			//c[4] = 0.5;
//			//c[5] = 0.191;
//			//c[6] = 0.515;
//			//c[7] = 0.84;
//			//c[8] = 0.5;
//			//c[9] = 0.392;
//			//c[10] = 0.737;

//      // sceneRevistaICRA09-exhaustive.iv
//      c[0] = 0.221;
//			c[1] = 0.492;
//			c[2] = 0.0;
//			c[3] = 0.5;
//			c[4] = 0.513;
//			c[5] = 0.205;
//			c[6] = 0.492;
//			c[7] = 0.882;
//			c[8] = 0.923;
//			c[9] = 0.626;
//			c[10] = 0.308;

//   //   // sceneRevistaICRA09-other.iv
//   //   c[0] = 0.887;
//			//c[1] = 0.682;
//			//c[2] = 0.405;
//			//c[3] = 0.338;
//			//c[4] = 0.323;
//			//c[5] = 0.246;
//			//c[6] = 0.467;
//			//c[7] = 0.810;
//			//c[8] = 0.477;
//			//c[9] = 0.528;
//			//c[10] = 0.708;

//      _init = new Sample(_wkSpace->getDimension());
//			initSamp()->setCoords(c);
//			_samples->add(_init);
	
//			/*
//			<KthReal> parametersCINI;
//			vector<KthReal> controlsCINI;
//			for(int i=0; i<11;i++) controlsCINI.push_back(c[i]);
//			_wkSpace->getRobot(0)->control2Parameters(controlsCINI,parametersCINI);
//			cout<<"CONTROLS CINI";
//			for(int i=0; i<controlsCINI.size();i++)
//			{
//				cout << ", "<< controlsCINI[i];
//			}
//			cout<<flush<<endl;
//			cout<<"PARAMETERS CINI";
//			for(int i=0; i<parametersCINI.size();i++)
//			{
//				cout << ", "<< parametersCINI[i];
//			}
//			cout<<flush<<endl;
//			*/

//			//set neightrheshold equal to distance between init and goal configs
//			double dist=0;
//			for(int i =0; i < _wkSpace->getDimension(); i++)
//			{
//				double s = goalSamp()->getCoords()[i] - initSamp()->getCoords()[i];
//				dist += (s*s);
//			}
//			dist = sqrt(dist);
//			_neighThress = dist;
//			cout<<"...._neighThress = "<<_neighThress<<endl<<flush;

//		  }
//		  else if(_wkSpace->getDimension()==19)
//		  {
//			    cout << "Setting initial and goal configurations (all joints assumed)"<<endl<<flush;
				
//        std::vector<KthReal> c(19);
//				int h=0;
//				//PARAMETERS CGOAL,
//				c[h++] = 0.1715;
//				c[h++] = 0.18605;
//				c[h++] = 0.736189;
//				c[h++] = 0.84121;
//				c[h++] = 0.351502;
//				c[h++] = 0.607788;
//				c[h++] = 0.921575;
//				c[h++] = 0.5;
//				c[h++] = 0.69032;
//				c[h++] =  0.726542;
//				c[h++] = 0.624597;
//				c[h++] = 0.641927;
//				c[h++] = 0.780143;
//				c[h++] =  0.258;
//				c[h++] =  0.515;
//				c[h++] = 0.856;
//				c[h++] =  0.5;
//				c[h++] = 0.392;
//				c[h++] = 0.737;
//                                _goal = new Sample(_wkSpace->getDimension());
//				goalSamp()->setCoords(c);
//				_samples->add(_goal);

//				//PARAMETERS CINI,
//				h=0;
//				c[h++] =  0.8055;
//				c[h++] =  0.315836;
//				c[h++] =  0.725758;
//				c[h++] =  0.681895;
//				c[h++] =  0.40439;
//				c[h++] =  0.685201;
//				c[h++] =  0.869964;
//				c[h++] =  0.5;
//				c[h++] =  0.755927;
//				c[h++] =  0.748784;
//				c[h++] =  0.581193;
//				c[h++] =  0.728463;
//				c[h++] =  0.807463;
//				c[h++] =  0.191;
//				c[h++] =  0.515;
//				c[h++] =  0.84;
//				c[h++] =  0.5;
//				c[h++] =  0.392;
//				c[h++] =  0.737;
//                                _init = new Sample(_wkSpace->getDimension());
//				initSamp()->setCoords(c);
//				_samples->add(_init);

			
//				//set neightrheshold equal to distance between init and goal configs
//				double dist=0;
//				for(int i =0; i < _wkSpace->getDimension(); i++)
//				{
//					double s = goalSamp()->getCoords()[i] - initSamp()->getCoords()[i];
//					dist += (s*s);
//				}
//				dist = sqrt(dist);
//				_neighThress = dist;
//				cout<<"...._neighThress = "<<_neighThress<<endl<<flush;
//		  }
//		  else
//			  cout << "ERROR: not init/goal not set - dimensions do not fit"<<endl<<flush;
//			  cout << "dimensionWorkspace = "<<_wkSpace->getDimension() <<endl<<flush;


//	  }

    void PRMHandPlannerICRAthumb::saveData()
	{
		if(_solved) 
		{
			vector<KthReal> coordvector;
      RobConf* joints;
			Sample *init, *goal, *init2, *goal2;
			KthReal initthumb;

			cout << "Save PATH to FILE"<<endl;
			FILE *fpr,*fph;
			fpr = fopen ("robotconf.txt","wt");
			if(fpr==NULL)
			{
				cout<<"Cannot open robotconf.txt for writting..."<<endl;
			}
			fph = fopen ("handconf.txt","wt");
			if(fph==NULL)
			{
				cout<<"Cannot open handconf.txt for writting..."<<endl;
			}


			for(unsigned i = 0; i < _path.size()-1; i++){
			//compute intermediate points
				init = _path[i];
				goal = _path[i+1];
				if(i==0) initthumb = _path[0]->getCoords()[0];
				else initthumb = goal2->getCoords()[0];

				_locPlanner->setInitSamp(_path[i]);
				_locPlanner->setGoalSamp(_path[i+1]);
				((ManhattanLikeLocalPlanner*) _locPlanner)->setIntermediateConfs();
				init2 = ((ManhattanLikeLocalPlanner*) _locPlanner)->initSamp2();
				goal2 = ((ManhattanLikeLocalPlanner*) _locPlanner)->goalSamp2();

			//Save Init configuration 
				coordvector.clear();
				coordvector.push_back( initthumb ); 
				for(int k = 1; k < _wkSpace->getDimension(); k++)
					coordvector.push_back( init->getCoords()[k] ); 

				//convert from controls to real coordinates
				_wkSpace->getRobot(0)->control2Pose(coordvector);
				joints = _wkSpace->getRobot(0)->getCurrentPos();
				
				//write to file
				writeFiles(fpr,fph,joints);
				
			//Save Init2 configuration 
				coordvector.clear();
				for(int k = 0; k < _wkSpace->getDimension(); k++)
					coordvector.push_back( init2->getCoords()[k] );

				//convert from controls to real coordinates
				_wkSpace->getRobot(0)->control2Pose(coordvector);
				joints = _wkSpace->getRobot(0)->getCurrentPos();
				
				//write to file
				writeFiles(fpr,fph,joints);

				
			//Save Goal2 configuration 
				coordvector.clear();
				for(int k = 0; k < _wkSpace->getDimension(); k++)
					coordvector.push_back( goal2->getCoords()[k] );

				//convert from controls to real coordinates
				_wkSpace->getRobot(0)->control2Pose(coordvector);
				joints = _wkSpace->getRobot(0)->getCurrentPos();
				
				//write to file
				writeFiles(fpr,fph,joints);

			//Last move towards GOAL
				if(i == _path.size()-2)
				{
					coordvector.clear();
					for(int k = 0; k < _wkSpace->getDimension(); k++)
						coordvector.push_back( goal->getCoords()[k] );

					//convert from controls to real coordinates
					_wkSpace->getRobot(0)->control2Pose(coordvector);
					joints = _wkSpace->getRobot(0)->getCurrentPos();
				
					//write to file
					writeFiles(fpr,fph,joints);
				}
			}
			fclose(fpr);
			fclose(fph);
		}
		else{
			cout << "Sorry: Path not yet found"<<endl;
		}
    }


  }
};
