/***************************************************************************
*               Generated by StarUML(tm) C++ Add-In                        *
***************************************************************************/
/***************************************************************************
*                                                                          *
*           Institute of Industrial and Control Engineering                *
*                 Technical University of Catalunya                        *
*                        Barcelona, Spain                                  *
*                                                                          *
*                Project Name:       Kautham Planner                       *
*                                                                          *
*     Copyright (C) 2007 - 2009 by Alexander Pérez and Jan Rosell          *
*            alexander.perez@upc.edu and jan.rosell@upc.edu                *
*                                                                          *
*             This is a motion planning tool to be used into               *
*             academic environment and it's provided without               *
*                     any warranty by the authors.                         *
*                                                                          *
*          Alexander Pérez is also with the Escuela Colombiana             *
*          de Ingeniería "Julio Garavito" placed in Bogotá D.C.            *
*             Colombia.  alexander.perez@escuelaing.edu.co                 *
*                                                                          *
***************************************************************************/
/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 ***************************************************************************/
 
 
 

#include "link.h"
#include "ivpqpelement.h"
#include <mt/point3.h>



namespace libProblem {

  //!	Unique constructor.
  /*!	This constructor provide the way to create any Link and you progressively can build
  *		any cinematic chain robot from the absolute reference frame
  *		to Final Efector frame.
  *		\param ivFile is the path string in the Inventor file that contain the link solid.
  *		\param scale is the global scale for this link and It is only used for 
  *		graphical representation.
  */
  Link::Link(string ivFile, KthReal scale, DHAPPROACH dhType, LIBUSED lib){
    libs = lib;
    switch(libs){
      case INVENTOR:
        element = new IVElement(ivFile,scale);
      case IVPQP:
        element = new IVPQPElement(ivFile,scale);
        break;
      case IVSOLID:
        
      default:
        element = NULL;
    }
	  a = (KthReal)0.0;
	  alpha = (KthReal)0.0;
	  theta = (KthReal)0.0;
	  d = (KthReal)0.0;
	  movable = true;
	  rotational = true;
	  armed = false;
	  lowLimit = (KthReal)-M_PI;
	  hiLimit = (KthReal)M_PI;
	  value = (KthReal)0.0;
    zeroOffset = (KthReal)0.0;
	  parent = NULL;
	  childs.clear();
	  this->dhType = dhType;
	  //KthReal matTemp[4][4]={{1.0f,0.0f,0.0f,0.0f},{0.0f,1.0f,0.0f,0.0f},
    // {0.0f,0.0f,1.0f,0.0f},{0.0f,0.0f,0.0f,1.0f}};
	  
    for(int i=0; i<4 ; i++)
      for(int j=0 ; j<4; j++)
        if(i == j)
			    dhMatrix[i][j]= (KthReal)1.0;
        else
          dhMatrix[i][j]= (KthReal)0.0;


    hasChanged = false;
    preTransform = NULL;

  }

  //!	This member function set the value of armed attribute.
  /*!	This member function set the value of armed attribute, Its means that all 
  *		robot is armed, and its Links and its links are complete. When this 
  *		attribute is set to true is not posible to change fixed D - H parameters.*/
  void Link::setArmed(){
    if(!armed){
	    armed = true;
      if(dhType == DHSTANDARD){
		    dhMatrix[0][0] = cos(theta);							dhMatrix[0][1] = -cos(alpha)*sin(theta);
		    dhMatrix[0][2] = sin(alpha)*sin(theta);	  dhMatrix[0][3] = a*cos(theta);

		    dhMatrix[1][0] = sin(theta);							dhMatrix[1][1] = cos(alpha)*cos(theta);
		    dhMatrix[1][2] = -sin(alpha)*cos(theta);	dhMatrix[1][3] = a*sin(theta);

		    /*dhMatrix[2][0] = 0 */                   dhMatrix[2][1] = sin(alpha);
		    dhMatrix[2][2] = cos(alpha);							dhMatrix[2][3] = d;
	    }else{ //dhType == DHMODIFIED
		    dhMatrix[0][0] = cos(theta);							dhMatrix[0][1] = -sin(theta);
		    /*dhMatrix[0][2] = 0;*/                   dhMatrix[0][3] = a;

		    dhMatrix[1][0] = cos(alpha)*sin(theta);	  dhMatrix[1][1] = cos(alpha)*cos(theta);
		    dhMatrix[1][2] = -sin(alpha);	            dhMatrix[1][3] = -d*sin(alpha);

		    dhMatrix[2][0] = sin(alpha)*sin(theta);   dhMatrix[2][1] = sin(alpha)*cos(theta);
		    dhMatrix[2][2] = cos(alpha);							dhMatrix[2][3] = d*cos(alpha);
	    }
      hasChanged = true;
      calculatePnO();
    }
  }

  //!	This function set a Link of variable value.
  /*! This funcition set a Link of variable value between 0 and 1, corresponding 
  *		to lowLimit and hiLimit.This function changes the value of the variable which
  *		depends directly on the configuration of the Linkt. This Function can be  
  *		rotarcional or telescopic and  for this reason it can changes the 
  *		value of \f$\theta\f$ o de \f$d\f$.
  *
  *		When the articular variable value has changed, we have to
  *		calculate  the transformation again with regard to absolute origin	
  *		that the associated Link  has had, that done it based on the
  *		transformation of the  previous link (prior) and the D-H parameters.
  *		This is possible only if the Link is armed and movable.
  */
  bool Link::setValue(KthReal q){
    if(armed && movable){
      if(q <= lowLimit)
        q = lowLimit;
      if(q >= hiLimit)
        q= hiLimit;
      
      value = q;
      q += zeroOffset;
		  if(rotational){
			  if(theta != q) 
          hasChanged = true;
        theta = q;
      }else{
        if(d != q) 
          hasChanged = true;
			  d = q	;
      }
      
		  calculatePnO();
      return true;
    }
    return false;
  }


  bool Link::setParameter(KthReal p){
    if(armed && movable){
      if(p < (KthReal)0.0) p=0;
	  else if(p > (KthReal) 1.0) p=1;
      return setValue( parameter2Value(p) );

      //if(p >= (KthReal)0.0 && p<= (KthReal) 1.0)
      //  return setValue( parameter2Value(p) );
      return false;
    }
    return false;
  }

  void Link::calculatePnO(){
	  //SbVec3f transTemp,  scaleTemp;
	  //SbRotation rotTemp, scaoriTemp;
	  KthReal tranv[3], rotv[4];

    if(hasChanged){ 
      if(dhType == DHSTANDARD){
	      if(rotational){
		      dhMatrix[0][0] = cos(theta);							dhMatrix[0][1] = -cos(alpha)*sin(theta);
		      dhMatrix[0][2] = sin(alpha)*sin(theta);	  dhMatrix[0][3] = a*cos(theta);
		      dhMatrix[1][0] = sin(theta);							dhMatrix[1][1] = cos(alpha)*cos(theta);
		      dhMatrix[1][2] = -sin(alpha)*cos(theta);	dhMatrix[1][3] = a*sin(theta);
	      }else{
		      dhMatrix[2][3] = d;
	      }
      }else{ //dhType == dhModified
	      if(rotational){
		      dhMatrix[0][0] = cos(theta);							dhMatrix[0][1] = -sin(theta);
		      dhMatrix[1][0] = cos(alpha)*sin(theta);	  dhMatrix[1][1] = cos(alpha)*cos(theta);
		      dhMatrix[2][0] = sin(alpha)*sin(theta);   dhMatrix[2][1] = sin(alpha)*cos(theta);
	      }else{
		      dhMatrix[1][3] = -d*sin(alpha);           dhMatrix[2][3] = d*cos(alpha);
	      }
      }
    
      mt::Rotation tempRot(Matrix3x3(dhMatrix[0][0],dhMatrix[0][1],dhMatrix[0][2],
                           dhMatrix[1][0],dhMatrix[1][1],dhMatrix[1][2],
                           dhMatrix[2][0],dhMatrix[2][1],dhMatrix[2][2]));
      mt::Point3 tempTran(dhMatrix[0][3],dhMatrix[1][3],dhMatrix[2][3]);
  	  
      mt::Transform dhTemp(tempRot, tempTran);
  									 
	    if(parent != NULL){
		    absoluteTransform = *(parent->getTransformation());
      }

      if(preTransform != NULL)
        absoluteTransform *= *preTransform;

      absoluteTransform *= dhTemp;

      tempTran = absoluteTransform.getTranslation();
      tempRot = absoluteTransform.getRotation();
      for(int j=0; j<3; j++){
        tranv[j] = tempTran[j];
        rotv[j] = tempRot[j];
      }
      rotv[3] = tempRot[3];
     
      element->setPosition(tranv);
      element->setOrientation(rotv);

      for(unsigned int i = 0; i < childs.size(); i++){
        ((Link*)childs[i])->forceChange(this);
        ((Link*)childs[i])->calculatePnO();
      }
      
      hasChanged = false;
    } 
  }

  //!	This function set all D-H parameters. Angles are in degrees.  
  //! The theta parameter of D-H is the zeroOffset to home position.
  void Link::setDHPars(KthReal theta, KthReal d, KthReal a, KthReal alpha){
	  this->theta = theta;
	  this->d = d;
	  this->a = a;
	  this->alpha = alpha;
	  if(rotational)
		  zeroOffset = this->theta;
	  else
		  zeroOffset = this->d;
  }

  //! This member function set low and hi limits to articular variable. 
  //! If limits represents angles, there are in radians otherwise there are in milimeters.
  void Link::setLimits(KthReal low, KthReal hi){
	  if(!armed){
		  this->lowLimit = low;
		  this->hiLimit = hi;
	  }
  }

  KthReal* Link::getLimits(bool low){
    if(low)
      return &lowLimit;
    else
      return &hiLimit;
  }

  void Link::setParent(Link* par){
    if(!armed){
      parent=par;
      par->addChild(this);
      setArmed();
    }
  }

  unsigned int Link::addChild(Link* child){
    childs.push_back(child);
    return childs.size();
  }

  bool Link::changeChilds(){
    if(childs.size()>0){
      for(unsigned int i = 0; i < childs.size(); i++)
        ((Link*)childs[i])->forceChange(this);
      return true;
    }
    return false;
  }

  bool Link::setPreTransform(KthReal x, KthReal y, KthReal z, 
                              KthReal wx, KthReal wy, KthReal wz, KthReal angle){ 
    if(preTransform == NULL){
      mt::Point3 tempTran(x,y,z);
      mt::Rotation tempRot(mt::Unit3(wx,wy,wz),angle);
      preTransform = new mt::Transform(tempRot,tempTran);
      return true;
    }
    return false;
  }

}

