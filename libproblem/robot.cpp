/***************************************************************************
 *               Generated by StarUML(tm) C++ Add-In                        *
 ***************************************************************************/
/***************************************************************************
 *                                                                          *
 *           Institute of Industrial and Control Engineering                *
 *                 Technical University of Catalunya                        *
 *                        Barcelona, Spain                                  *
 *                                                                          *
 *                Project Name:       Kautham Planner                       *
 *                                                                          *
 *     Copyright (C) 2007 - 2011 by Alexander Pérez and Jan Rosell          *
 *            alexander.perez@upc.edu and jan.rosell@upc.edu                *
 *                                                                          *
 *             This is a motion planning tool to be used into               *
 *             academic environment and it's provided without               *
 *                     any warranty by the authors.                         *
 *                                                                          *
 *          Alexander Pérez is also with the Escuela Colombiana             *
 *          de Ingeniería "Julio Garavito" placed in Bogotá D.C.            *
 *             Colombia.  alexander.perez@escuelaing.edu.co                 *
 *                                                                          *
 ***************************************************************************/
/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 ***************************************************************************/

#include "robot.h"
#include "ivsolidelement.h"
#include <libutil/kauthamdefs.h>
#include "inversekinematic.h"
#include "ivkintx90.h"
#include "ivkintxhand.h"
#include "ivkinhand.h"
#include "ivkin2drr.h"
#include "constrainedkinematic.h"
#include "consbronchoscopykin.h"
#include <mt/point3.h>
#include <mt/rotation.h>
#include <cstdlib>
#include <cstdio>
#include <fstream>
#include <string>
#include <libutil/pugixml/pugixml.hpp>
#include <Inventor/VRMLnodes/SoVRMLExtrusion.h>

using namespace std;
using namespace Kautham;
using namespace pugi;

namespace libProblem
{
Robot::Robot(string robFile, KthReal scale, LIBUSED lib)
{
  _linkPathDrawn = -1;
  nTrunk = 0;
  libs = lib;
  this->scale = scale;
  this->armed = false;
  se3Enabled = false;
  _autocoll = false;
  _hasChanged = false;
  numControls = 0;
  // Inialization of SE3 configurations.
  _homeConf.setSE3();
  _initConf.setSE3();
  _goalConf.setSE3();
  _currentConf.setSE3();
  _ikine = NULL;
  _constrainKin = NULL;
  _weights = NULL;
  visModel = NULL;
  _graphicalPath = NULL;
  for (int i = 0; i < 7; i++)
    for (int j = 0; j < 2; j++)
    {
      _homeLimits[i][j] = 0.;
      _spatialLimits[i][j] = 0.;
    }
  const KthReal toRad = M_PI / 180.;

  //  if the file has rob extension it will be parsed in order to
  //  create the links, otherwise there are create the base "Link"
  //  as a freefly.
  fstream fin;
  fin.open(robFile.c_str(), ios::in);
  if (fin.is_open())
  { // The file already exists.
    fin.close();
    string::size_type loc = robFile.find(".rob", 0);
    string dir;
    if (loc != string::npos)
    { // It means that the robot is a kinematic chain.
      dir = robFile.substr(0, robFile.find_last_of("/") + 1);

      // Opening the file with the new pugiXML library.
      xml_document doc;
      xml_parse_result result = doc.load_file(robFile.c_str());

      string tmpString = "";
      if (result)
      {
        //  Once the file has been parsed, it contains the links information
        //  and now the links could be constructed.

        name = doc.child("Robot").attribute("name").value();

        tmpString = doc.child("Robot").attribute("DHType").value();
        if (tmpString == "Standard")
          dhApproach = DHSTANDARD;
        else
          dhApproach = DHMODIFIED;

        tmpString = doc.child("Robot").attribute("robType").value();
        if (tmpString == "Tree")
          robType = TREE;
        else
          robType = CHAIN;

        int numLinks = doc.child("Robot").child("Joints").attribute("size").as_int();

        _weights = new RobWeight(numLinks - 1);

        if (doc.child("Robot").child("WeightSE3"))
        {
          KthReal tra = 1.;
          KthReal rot = 1.;
          xml_node tmp = doc.child("Robot").child("WeightSE3");
          if (tmp.attribute("rho_t"))
            tra = (KthReal)tmp.attribute("rho_t").as_double();
          if (tmp.attribute("rho_r"))
            rot = (KthReal)tmp.attribute("rho_r").as_double();
          _weights->setSE3Weight(tra, rot);

        }
        else
          _weights->setSE3Weight(1., 1.);

        // Initialization of the RnConf part of the RobConf for each
        // special poses, the initial, the goal, the Home and the current poses.

        _homeConf.setRn(numLinks - 1);
        _currentConf.setRn(numLinks - 1);
        _initConf.setRn(numLinks - 1);
        _goalConf.setRn(numLinks - 1);

        xml_node linkNode = doc.child("Robot").child("Joints");
        KthReal* preTransP = NULL;
        KthReal preTrans[7] = {0., 0., 0., 0., 0., 0., 0.};
        int i = 0;
        KthReal limMin, limMax;
        limMin = limMax = 0.;
        for (xml_node_iterator it = linkNode.begin(); it != linkNode.end(); ++it)
        {
          xml_node preTNode = (*it).child("PreTrans");
          if (preTNode != NULL)
          {
            preTransP = preTrans;
            preTrans[0] = (KthReal)preTNode.attribute("X").as_double();
            preTrans[1] = (KthReal)preTNode.attribute("Y").as_double();
            preTrans[2] = (KthReal)preTNode.attribute("Z").as_double();
            preTrans[3] = (KthReal)preTNode.attribute("WX").as_double();
            preTrans[4] = (KthReal)preTNode.attribute("WY").as_double();
            preTrans[5] = (KthReal)preTNode.attribute("WZ").as_double();
            preTrans[6] = (KthReal)preTNode.attribute("TH").as_double() * toRad;
          }

          limMin = (KthReal)(*it).child("Limits").attribute("Low").as_double();
          limMax = (KthReal)(*it).child("Limits").attribute("Hi").as_double();
          if ((*it).child("Description").attribute("rotational").as_bool())
          {
            limMin *= toRad;
            limMax *= toRad;
          }

          addLink((*it).attribute("name").value(), dir + (*it).attribute("ivFile").value(),
                  (KthReal)(*it).child("DHPars").attribute("theta").as_double() * toRad,
                  (KthReal)(*it).child("DHPars").attribute("d").as_double(),
                  (KthReal)(*it).child("DHPars").attribute("a").as_double(),
                  (KthReal)(*it).child("DHPars").attribute("alpha").as_double() * toRad,
                  (*it).child("Description").attribute("rotational").as_bool(),
                  (*it).child("Description").attribute("movable").as_bool(), limMin, limMax,
                  (KthReal)(*it).child("Weight").attribute("weight").as_double(),
                  (*it).child("Parent").attribute("name").value(), preTransP);

          if (i > 0)
          { //First link is ommited because it is the base.
            if ((*it).child("Weight"))
              _weights->setRnWeigh(i - 1, (KthReal)(*it).child("Weight").attribute("weight").as_double());
            else
              _weights->setRnWeigh(i - 1, (KthReal)1.0);
          }

          i++;

          preTransP = NULL;

        }

        //  =====================
        //  Once the links were added, the controls can be configured
        //  Creating the mapping Matrix between controls and DOF parameters and initializing it.
        controlsName = "";
        mapMatrix = new KthReal*[6 + _currentConf.getRn().getDim()];
        offMatrix = new KthReal[6 + _currentConf.getRn().getDim()];

        numControls = doc.child("Robot").child("ControlSet").attribute("size").as_int();
        nTrunk = doc.child("Robot").child("ControlSet").attribute("nTrunk").as_int();

        for (int i = 0; i < 6 + _currentConf.getRn().getDim(); i++)
        {
          mapMatrix[i] = new KthReal[numControls];
          offMatrix[i] = (KthReal)0.0;
          for (unsigned int j = 0; j < numControls; j++)
            mapMatrix[i][j] = (KthReal)0.0;
        }

        xml_node tmpNode = doc.child("Robot").child("ControlSet").child("Offset");
        xml_node::iterator it;
        string dofName = "";
        for (it = tmpNode.begin(); it != tmpNode.end(); ++it)
        {          // PROCESSING ALL DOF FINDED
          dofName = (*it).attribute("name").value();
          if (dofName == "X")
          {
            se3Enabled = true;
            offMatrix[0] = (KthReal)(*it).attribute("value").as_double();
          }
          else if (dofName == "Y")
          {
            se3Enabled = true;
            offMatrix[1] = (KthReal)(*it).attribute("value").as_double();
          }
          else if (dofName == "Z")
          {
            se3Enabled = true;
            offMatrix[2] = (KthReal)(*it).attribute("value").as_double();
          }
          else if (dofName == "X1")
          {
            se3Enabled = true;
            offMatrix[3] = (KthReal)(*it).attribute("value").as_double();
          }
          else if (dofName == "X2")
          {
            se3Enabled = true;
            offMatrix[4] = (KthReal)(*it).attribute("value").as_double();
          }
          else if (dofName == "X3")
          {
            se3Enabled = true;
            offMatrix[5] = (KthReal)(*it).attribute("value").as_double();

          }
          else
          {    // It's not a SE3 control and could have any name.
               //  Find the index orden into the links vector without the first static link.
            for (int ind = 0; ind < _currentConf.getRn().getDim(); ind++)
              if (dofName == links[ind + 1]->getName())
              {
                offMatrix[6 + ind] = (KthReal)(*it).attribute("value").as_double();
                break;
              }
          }
        }

        tmpNode = doc.child("Robot").child("ControlSet");
        string nodeType = "";
        int cont = 0;
        for (it = tmpNode.begin(); it != tmpNode.end(); ++it)
        {
          nodeType = it->name();
          if (nodeType == "Control")
          {                       // Processing all controls found.
            xml_node::iterator itDOF;
            KthReal eigVal = (KthReal)(*it).attribute("eigValue").as_double();
            dofName = "";
            for (itDOF = (*it).begin(); itDOF != (*it).end(); ++itDOF)
            {                       // PROCESSING ALL DOF FINDED
              dofName = itDOF->attribute("name").value();
              if (dofName == "X")
              {
                se3Enabled = true;
                mapMatrix[0][cont] = eigVal * (KthReal)itDOF->attribute("value").as_double();
              }
              else if (dofName == "Y")
              {
                se3Enabled = true;
                mapMatrix[1][cont] = eigVal * (KthReal)itDOF->attribute("value").as_double();
              }
              else if (dofName == "Z")
              {
                se3Enabled = true;
                mapMatrix[2][cont] = eigVal * (KthReal)itDOF->attribute("value").as_double();
              }
              else if (dofName == "X1")
              {
                se3Enabled = true;
                mapMatrix[3][cont] = eigVal * (KthReal)itDOF->attribute("value").as_double();
              }
              else if (dofName == "X2")
              {
                se3Enabled = true;
                mapMatrix[4][cont] = eigVal * (KthReal)itDOF->attribute("value").as_double();
              }
              else if (dofName == "X3")
              {
                se3Enabled = true;
                mapMatrix[5][cont] = eigVal * (KthReal)itDOF->attribute("value").as_double();
              }
              else
              {      // It's not a SE3 control and could have any name.
                     //  Find the index orden into the links vector without the first static link.
                for (int ind = 0; ind < _currentConf.getRn().getDim(); ind++)
                  if (dofName == links[ind + 1]->getName())
                  {
                    mapMatrix[6 + ind][cont] = eigVal * (KthReal)itDOF->attribute("value").as_double();
                    break;
                  }
              }
            }             // for(itDOF = dofItem.begin(); itDOF != dofItem.end(); ++itDOF) {// PROCESSING ALL DOF FINDED

            if (controlsName != "")
              controlsName.append("|");
            controlsName.append((*it).attribute("name").value());

            cont++;

          }                            // closing if(nodeType == "Control" )
        }                       //closing for(it = tmpNode.begin(); it != tmpNode.end(); ++it) for all ControlSet childs

      }
      else
        // the result of the file pasers is bad
        cout << "The robot file: " << robFile << " can not be read." << std::endl;

    }
    else
    { //If robot is freeflying the robFile is a single Inventor file.
      robType = FREEFLY;
      name = "free";
      dhApproach = DHMODIFIED;
      addLink("", robFile, (KthReal)0.0, (KthReal)0.0, (KthReal)0.0, (KthReal)0.0, false, false, (KthReal)0.0,
              (KthReal)0.0, (KthReal)1.0, "");

      //==============
      //  The freeflying robot has posible movements in all SE3 space and it hasn't controls.
      mapMatrix = new KthReal*[6];
      offMatrix = new KthReal[6];
      for (int i = 0; i < 6; i++)
      {
        mapMatrix[i] = new KthReal[6];
        offMatrix[i] = (KthReal)0.5;
      }

      for (int i = 0; i < 6; i++)
        for (int j = 0; j < 6; j++)
          if (i == j)
            mapMatrix[i][j] = (KthReal)1.0;
          else
            mapMatrix[i][j] = (KthReal)0.0;
      controlsName = "X|Y|Z|X1|X2|X3";
      se3Enabled = true;
      numControls = 6;

      //======================
      //Now the associated weights
      _weights = new RobWeight(1);
      _weights->setSE3Weight(1., 1.);
      _weights->setRnWeigh(0, 1.);

    } // closing if(robType != FREEFLY

    for (int i = 0; i < 7; i++)
      _spatialLimits[i][0] = _spatialLimits[i][1] = (KthReal)0.0;

  }
  else
  { // File does not exists.
    fin.close();
    cout << "The Robot file: " << robFile << "doesn't exist. Please confirm it." << endl;
    robType = FREEFLY;
    name = "free";
    dhApproach = DHMODIFIED;
  }

  armed = true;
}

bool Robot::attachObject(Obstacle* obs, string linkName)
{
  try
  {
    attObj newObj;
    newObj.obs = obs;
    newObj.link = getLinkByName(linkName);
    mt::Transform tmpO;
    KthReal* pos = obs->getElement()->getPosition();
    tmpO.setTranslation(mt::Point3(pos[0], pos[1], pos[2]));
    pos = obs->getElement()->getOrientation();
    tmpO.setRotation(mt::Rotation(pos[0], pos[1], pos[2], pos[3]));
    newObj.trans = newObj.link->getTransformation()->inverse() * tmpO;
    _attachedObject.push_back(newObj);
    return true;
  }
  catch (...)
  {
    return false;
  }
}

void Robot::moveAttachedObj()
{
  KthReal pos[3] = {0.};
  KthReal ori[4] = {0.};
  list<attObj>::iterator it = _attachedObject.begin();
  for (it = _attachedObject.begin(); it != _attachedObject.end(); ++it)
  {
    mt::Transform tmp = *((*it).link->getTransformation());
    tmp *= (*it).trans;
    pos[0] = tmp.getTranslation().at(0);
    pos[1] = tmp.getTranslation().at(1);
    pos[2] = tmp.getTranslation().at(2);
    (*it).obs->getElement()->setPosition(pos);

    ori[0] = tmp.getRotation().at(0);
    ori[1] = tmp.getRotation().at(1);
    ori[2] = tmp.getRotation().at(2);
    ori[3] = tmp.getRotation().at(3);
    (*it).obs->getElement()->setOrientation(ori);
  }
}

bool Robot::detachObject(string linkName)
{
  bool found = false;

  //cout << "Flag_1" << endl;

  cout << "_attachedObject.size() " << _attachedObject.size() << endl;

  for (list<attObj>::iterator it = _attachedObject.begin(); it != _attachedObject.end() && !_attachedObject.empty();
      ++it)
  {
    cout << (*it).obs->getName() << endl;
    if ((*it).toLink(linkName))
    {
      //cout << "Flag_3" << endl;
      cout << "Executing _attachedObject.erase(it) for Object in " << (*it).link->getName() << endl;

      _attachedObject.erase(it);

      cout << "Done" << endl;
      //cout << "Flag_4" << endl;
      found = true;
      //cout << "Flag_5" << endl;

    }
  }

  //cout << "Flag_6" << endl;
  return found;
}

Link* Robot::getLinkByName(string linkName)
{
  for (size_t i = 0; i < links.size(); ++i)
  {
    if (links[i]->getName() == linkName)
      return links[i];
  }
  return NULL;
}

string Robot::getDOFNames()
{
  string tmp = "X|Y|Z|X1|X2|X3";
  for (unsigned int i = 1; i < links.size(); i++)
  {
    tmp.append("|");
    tmp.append(links[i]->getName());
  }
  return tmp;
}

//! This method sets the new value for a particular dof of a particular
//! control
bool Robot::setControlItem(string control, string dof, KthReal value)
{
  // First I will found the column index looking for "|" number before the control name.
  string::size_type pos = controlsName.find(control, 0);
  if (pos == string::npos)
    return false;
  int j = 0;
  string::size_type trick = controlsName.find("|", 0);
  while (trick < pos)
  {
    trick = controlsName.find("|", trick + 1);
    j++;
  }
  for (unsigned int i = 1; i < links.size(); i++)
    if (links[i]->getName() == dof)
    { // Now I am finding the row index.
      mapMatrix[i][j] = value;
      return true;
    }
  return false;
}

//! This member function allows to change the values of every
//! limit as well: x, y, z, wx, wy, wz, angle. There are respectively
//! the position and orientation of all the robot. These values are
//! in the world frame.
bool Robot::setLimits(int member, KthReal min, KthReal max)
{
  if (member >= 0 && member < 7)
  {
    _spatialLimits[member][0] = min;
    _spatialLimits[member][1] = max;
    // It needs to recalculate the limits in home frame.
    recalculateHomeLimits();
    return true;
  }
  return false;
}

void Robot::recalculateHomeLimits()
{
  mt::Point3 Pmin_W(_spatialLimits[0][0], _spatialLimits[1][0], _spatialLimits[2][0]);
  mt::Point3 Pmax_W(_spatialLimits[0][1], _spatialLimits[1][1], _spatialLimits[2][1]);
  mt::Point3 Pmin_H, Pmax_H;
  mt::Transform homeInv = _homeTrans.inverse();
  Pmin_H = homeInv * Pmin_W;
  Pmax_H = homeInv * Pmax_W;
  if (Pmin_H[0] == Pmax_H[0])
  {
    _homeLimits[0][0] = 0;                // Sets the Xmin in home frame
    _homeLimits[0][1] = 0;                // Sets the Xmax in home frame
  }
  else
  {
    _homeLimits[0][0] = Pmin_H[0];        // Sets the Xmin in home frame
    _homeLimits[0][1] = Pmax_H[0];        // Sets the Xmax in home frame
  }

  if (Pmin_H[1] == Pmax_H[1])
  {
    _homeLimits[1][0] = 0;                // Sets the Xmin in home frame
    _homeLimits[1][1] = 0;                // Sets the Xmax in home frame
  }
  else
  {
    _homeLimits[1][0] = Pmin_H[1];        // Sets the Ymin in home frame
    _homeLimits[1][1] = Pmax_H[1];        // Sets the Ymax in home frame
  }

  if (Pmin_H[2] == Pmax_H[2])
  {
    _homeLimits[2][0] = 0;                // Sets the Xmin in home frame
    _homeLimits[2][1] = 0;                // Sets the Xmax in home frame
  }
  else
  {
    _homeLimits[2][0] = Pmin_H[2];        // Sets the Zmin in home frame
    _homeLimits[2][1] = Pmax_H[2];        // Sets the Zmax in home frame
  }

}

bool Robot::setConstrainedKinematic(CONSTRAINEDKINEMATICS type)
{
  switch (type)
  {
    case Kautham::UNCONSTRAINED:
      _constrainKin = NULL;
      break;
    case Kautham::BRONCHOSCOPY:
      _constrainKin = new ConsBronchoscopyKin(this);
      break;
    default:
      cout << "The Constrained Kinematic model has not be configured properly.\n"
          << "See the ConsBronchoscopyKin of the Robot class to call the constructor. " << endl;
      _constrainKin = NULL;
      return false;
  }
  return true;
}

bool Robot::setConstrainedKinematicParameter(string name, KthReal value)
{
  if (_constrainKin != NULL)
    return _constrainKin->setParameter(name, value);
  return false;
}

RobConf& Robot::ConstrainedKinematics(vector<KthReal> &target)
{
  if (_constrainKin != NULL)
  {
    //First i try to connect to the remote object
    //if this pointer is not null, the object has been instantiate correctly.
    _constrainKin->setTarget(target);
    if (_constrainKin->solve())
    {
      return _constrainKin->getRobConf();
    }
  }
  return _currentConf;
}

bool Robot::setInverseKinematic(INVKINECLASSES type)
{
  switch (type)
  {
    case Kautham::RR2D:
      _ikine = new IvKin2DRR(this);
      break;
    case Kautham::TX90:
      _ikine = new IvKinTx90(this);
      break;
    case Kautham::HAND:
      _ikine = new IvKinHand(this);
      break;
    case Kautham::TX90HAND:
      _ikine = new IvKinTxHand(this);
      break;
    default:
      cout << "The new Inverse Kinematic model have not been configured properly.\n"
          << "See the setInverseKinematic of the Robot class to call the constructor. " << endl;
      _ikine = NULL;
      return false;
  }
  return true;
}

bool Robot::setInverseKinematicParameter(string name, KthReal value)
{
  if (_ikine != NULL)
    return _ikine->setParameter(name, value);
  return false;
}

bool Robot::Kinematics(RobConf *robq)
{
  bool se = Kinematics(robq->getSE3());
  if (se && Kinematics(robq->getRn()))
    return true;
  else
    return false;
}

bool Robot::Kinematics(RobConf& robq)
{
  bool se = Kinematics(robq.getSE3());
  if (se && Kinematics(robq.getRn()))
    return true;
  else
    return false;
}

bool Robot::Kinematics(SE3Conf& q)
{
  vector<KthReal>& coor = q.getCoordinates();

  links[0]->getTransformation()->setTranslation(Point3(coor[0], coor[1], coor[2]));
  links[0]->getTransformation()->setRotation(Rotation(coor[3], coor[4], coor[5], coor[6]));
  links[0]->forceChange(NULL);

  _currentConf.setSE3(q);
  updateRobot();
  return true;
}

bool Robot::Kinematics(RnConf& q)
{

  /*
   if(q.getDim() == getNumJoints()){
   for(int i = 0; i < q.getDim(); i++)
   links[i+1]->setValue(q.getCoordinate(i));

   _currentConf.setRn(q);

   updateRobot();
   return true;
   }else
   return false;
   */

  if (q.getDim() > getNumJoints())
    return false;

  int n = getNumJoints();
  if (q.getDim() < n)
  {
    RnConf q2(n);
    int i;
    std::vector<KthReal> coords(n);
    for (i = 0; i < q.getDim(); i++)
      coords[i] = q.getCoordinate(i);
    for (; i < n; i++)
      coords[i] = 0.0;
    q2.setCoordinates(coords);

    for (int i = 0; i < q2.getDim(); i++)
      links[i + 1]->setValue(q2.getCoordinate(i));

    _currentConf.setRn(q2);
  }
  else
  { //q.getDim() == getNumJoints()
    for (int i = 0; i < q.getDim(); i++)
      links[i + 1]->setValue(q.getCoordinate(i));

    _currentConf.setRn(q);
  }

  updateRobot();
  return true;
}

bool Robot::Kinematics(Conf *q)
{
  vector<KthReal>& coor = q->getCoordinates();

  //cout << "q.gettype "<<q->getType()<<endl;
  switch (q->getType())
  {
    case SE3:
      links[0]->getTransformation()->setTranslation(Point3(coor[0], coor[1], coor[2]));
      links[0]->getTransformation()->setRotation(Rotation(coor[3], coor[4], coor[5], coor[6]));
      links[0]->forceChange(NULL);
      _currentConf.setSE3(q->getCoordinates());
      //cout<<"current conf ("<< _currentConf.getSE3()->getCoordinate(0)<<", "<< _currentConf.getSE3()->getCoordinate(1)<<
      //", "<< _currentConf.getSE3()->getCoordinate(2)<<")"<<endl;
      break;
    case SE2:
      links[0]->getTransformation()->setTranslation(Point3(coor[0], coor[1], (KthReal)0.0));
      links[0]->getTransformation()->setRotation(Rotation((KthReal)0.0, (KthReal)0.0, (KthReal)1.0, coor[2]));
      links[0]->forceChange(NULL);
      _currentConf.setSE3(q->getCoordinates());
      break;
    case Rn:
      if (q->getDim() == getNumJoints())
      {
        for (int i = 0; i < q->getDim(); i++)
          links[i + 1]->setValue(q->getCoordinate(i));

        _currentConf.setRn(q->getCoordinates());
      }
      //cout<<"current conf Link[0] = "<< _currentConf.getRn().getCoordinate(0)<<endl;
      break;
    default:
      return false;
  }
  updateRobot();
  return true;
}

//!Call to inverseKinematics given the target defined as:
//! a) the tcp transform
//! b) a tcp transform and configuration parameters e.g. for the TX90: (l/r,ep/en,wp/wn)
RobConf& Robot::InverseKinematics(vector<KthReal> &target)
{
  if (_ikine != NULL)
  {
    //First i try to conect to the remote object
    //if this pointer is not null, the object has been instantiate correctly.
    _ikine->setTarget(target);
    if (_ikine->solve())
    {
      return _ikine->getRobConf();
    }
  }
  throw InvKinEx(0);
}

//!Call to inverseKinematics given:
//! a) the target defined as the tcp transform
//! b) a robot configuration used as a reference to copy its same configuration parameters e.g. for the TX90: (l/r,ep/en,wp/wn)
RobConf& Robot::InverseKinematics(vector<KthReal> &target, vector<KthReal> masterconf, bool maintainSameWrist)
{
  if (_ikine != NULL)
  {
    //First i try to conect to the remote object
    //if this pointer is not null, the object has been instantiate correctly.
    _ikine->setTarget(target, masterconf, maintainSameWrist);
    if (_ikine->solve())
    {
      return _ikine->getRobConf();
    }
  }
  throw InvKinEx(0);
}

bool Robot::autocollision(int t)
{
  //parameter t is used to only test the autocollision of the trunk part of a TREE robot
  //it is set to 0 in robot.h

  if (_hasChanged)
  {
    _autocoll = false;

    int maxLinksTested;
    //Restricted test to trunk in case of TREE robots
    if (robType == TREE && t == 1)
      maxLinksTested = nTrunk;
    else
      maxLinksTested = links.size();

    for (int i = 0; i < maxLinksTested; i++)
    {
      //Collision detection with the Palm are avoided
      if (links[i]->getName() == "Palm")
      {
        //cout <<"Palm detected - skipping collisions"<<endl;
        continue;
      }
      for (int j = i + 2; j < maxLinksTested; j++)
      {
        if (links[i]->getElement()->collideTo(links[j]->getElement()))
        {
          //cout <<"...collision between links "<<i<<" and "<<j<<endl;
          _autocoll = true;
          return _autocoll;
        }
      }
    }
  }
  //cout<<"hasChanged = "<<_hasChanged<<" return autocollision "<<_autocoll<<endl;
  return _autocoll;
}

bool Robot::collisionCheck(Obstacle *obs)
{
  if (autocollision())
    return true;
  else
  {
    if (obs->getEnableCollisions() == false)
      return false; //transparent obstacle...

    //First probe the more moveable Link
    for (int i = links.size() - 1; i >= 0; i--)
    {
      if (links[i]->getElement()->collideTo(obs->getElement()))
        return true;
    }
  }
  return false;
}

//! This method verifies if this robot collides with the robot rob passed as a parameter.
//! The method returns true when the two robots collide, otherwise returns false.
bool Robot::collisionCheck(Robot *rob)
{
  if (_autocoll || rob->autocollision())
    return true;

  for (int i = 0; i < links.size(); i++)
  {
    for (int j = 0; j < rob->getNumLinks(); j++)
    {
      if (links[i]->getElement()->collideTo(rob->getLink(j)->getElement()))  //{
        //cout <<"...collision between links "<<i<<" and "<<j<<endl;
        return true;
      //}
    }
  }
  return false;
}

//! This methods returns the distance between the robot and the obstacle passed as parameter.
//! The distance returned is between the endEfector or the most distal link, but
//! if parameter min is true, the distace is the
KthReal Robot::distanceCheck(Obstacle *obs, bool min)
{
  KthReal minDist = -1.0;
  KthReal tempDist = 0.0;
  if (autocollision())
    return (KthReal) - 1.0;
  else
    // First the most distal link
    minDist = links[links.size() - 1]->getElement()->getDistanceTo(obs->getElement());
  if (min)
  {
    for (size_t i = links.size() - 2; i >= 0; i--)
    {
      tempDist = links[i]->getElement()->getDistanceTo(obs->getElement());
      if (minDist > tempDist)
        minDist = tempDist;
    }
  }
  return minDist;
}

KthReal Robot::distanceCheck(Robot *rob, bool min)
{
  KthReal minDist = -1.0;
  KthReal tempDist = 0.0;

	//cout << "a" << endl;

  if (!autocollision()){
    // First the most distal link
    minDist = links[links.size() - 1]->getElement()->getDistanceTo(rob->getLink(0)->getElement());
	//cout << "b = " << minDist << endl;
	}
  if (min)
  {
	//cout << "c" << endl;
    for (size_t i = links.size() - 1; i > 0; i--){
		//cout << "c.1 = " << links.size() - 1 << endl;
		//cout << "c.2 = " << rob->getNumLinks() - 1 << endl;
      for (size_t j = rob->getNumLinks() - 1; j > 0; j--)
      {
		//cout << i << ", " << j << " " << endl;
		tempDist = links[i]->getElement()->getDistanceTo(rob->getLink(j)->getElement());
        if (minDist > tempDist)
          minDist = tempDist;
      }
	//cout << endl;
	}
  }
	//cout << "e" << endl;
  return minDist;
}

void Robot::setHomePos(Conf* qh)
{
  if (qh != NULL)
  {
    switch (qh->getType())
    {
      case SE3:
      case SE2:
      {
        _homeConf.setSE3(qh->getCoordinates());
        mt::Point3 tempTran(qh->getCoordinate(0), qh->getCoordinate(1), qh->getCoordinate(2));
        mt::Rotation tempRot(qh->getCoordinate(3), qh->getCoordinate(4), qh->getCoordinate(5), qh->getCoordinate(6));

        _homeTrans.setRotation(tempRot);
        _homeTrans.setTranslation(tempTran);

        recalculateHomeLimits();
      }
        break;
      case Rn:
        if (qh->getDim() == links.size() - 1)
        {
          _homeConf.setRn(qh->getCoordinates());
        }
    }
    Kinematics(qh);

  }
}

void Robot::setInitPos(Conf* qi)
{
  if (qi != NULL)
  {
    switch (qi->getType())
    {
      case SE3:
      case SE2:
        _initConf.setSE3(qi->getCoordinates());
        break;
      case Rn:
        if (qi->getDim() == links.size() - 1)
        {
          _initConf.setRn(qi->getCoordinates());
        }
    }
  }
}

void Robot::setGoalPos(Conf* qg)
{
  if (qg != NULL)
  {
    switch (qg->getType())
    {
      case SE3:
      case SE2:
        _goalConf.setSE3(qg->getCoordinates());
        break;
      case Rn:
        if (qg->getDim() == links.size() - 1)
        {
          _goalConf.setRn(qg->getCoordinates());
        }
    }
  }
}

bool Robot::addLink(string name, string ivFile, KthReal theta, KthReal d, KthReal a, KthReal alpha, bool rotational,
                    bool movable, KthReal low, KthReal hi, KthReal w, string parentName, KthReal preTrans[])
{
  Link* temp = new Link(ivFile, this->getScale(), dhApproach, libs);
  temp->setName(name);
  temp->setMovable(movable);
  temp->setRotational(rotational);
  temp->setDHPars(theta, d, a, alpha);
  temp->setLimits(low, hi);
  temp->setWeight(w);
  if (preTrans != NULL)
    temp->setPreTransform(preTrans[0], preTrans[1], preTrans[2], preTrans[3], preTrans[4], preTrans[5], preTrans[6]);
  if (links.size() > 0)
  {
    // There are finding the link by the name
    for (unsigned int i = links.size() - 1; i >= 0; i--)
      if (parentName == links[i]->getName())
      {
        temp->setParent(links[i]);
        break;
      }
  }

  temp->setArmed();
  temp->setValue(0.0); //This is the home position
  links.push_back(temp);
  return true;
}

//! This function return a pointer to the Link demanded.
/*! If you pass a Link identification not valid it will return a null pointer.*/
Link* Robot::getLink(unsigned int i)
{
  if (i < links.size())
    return links[i];
  else
    return NULL;
}

void* Robot::getModel()
{
  if (visModel == NULL)
  {
    switch (libs)
    {
      case IVPQP:
      case IVSOLID:
        SoSeparator* robot = new SoSeparator();
        robot->ref();
        for (unsigned int i = 0; i < links.size(); i++)
          robot->addChild(((IVElement*)links[i]->getElement())->ivModel(true));

        // Now is adding the three dimensional proposed path for the last link
        _pathSeparator = new SoSeparator();
        _pathSeparator->ref();
        _pathSeparator->setName("Path");
        SoMaterial* tmpMat = new SoMaterial();
        tmpMat->diffuseColor.setValue(0., 0., 1.);
        _pathSeparator->addChild(tmpMat);
        SoVRMLExtrusion* tmpVRML = new SoVRMLExtrusion();
        //_pathSeparator->setName("Path");
        tmpVRML->solid.setValue(true);
        float diag = diagLimits() / 100.;
        diag = diag < 2. ? 2. : diag;
        tmpVRML->scale.setValue(diag, diag);
        float vertex[13][2];
        vertex[0][0] = 0.1000;
        vertex[0][1] = 0.;
        vertex[1][0] = 0.0866;
        vertex[1][1] = 0.0500;
        vertex[2][0] = 0.0500;
        vertex[2][1] = 0.0866;
        vertex[3][0] = 0.0000;
        vertex[3][1] = 0.1000;
        vertex[4][0] = -0.0500;
        vertex[4][1] = 0.0866;
        vertex[5][0] = -0.0866;
        vertex[5][1] = 0.0500;
        vertex[6][0] = -0.1000;
        vertex[6][1] = 0.0000;
        vertex[7][0] = -0.0866;
        vertex[7][1] = -0.0500;
        vertex[8][0] = -0.0500;
        vertex[8][1] = -0.0866;
        vertex[9][0] = -0.0000;
        vertex[9][1] = -0.1000;
        vertex[10][0] = 0.0500;
        vertex[10][1] = -0.0866;
        vertex[11][0] = 0.0866;
        vertex[11][1] = -0.0500;
        vertex[12][0] = 0.1000;
        vertex[12][1] = 0.;
        tmpVRML->crossSection.setValues(0, 13, vertex);
        _graphicalPath = new SoMFVec3f();
        tmpVRML->spine.connectFrom(_graphicalPath);
        _pathSeparator->addChild(tmpVRML);

        robot->addChild(_pathSeparator);
        visModel = (void*)robot;
        break;
    }
  }
  return visModel;
}

float Robot::diagLimits()
{
  float dia = 0.;
  for (int i = 0; i < 3; i++)
    dia += (_homeLimits[i][1] - _homeLimits[i][0]) * (_homeLimits[i][1] - _homeLimits[i][0]);
  return sqrt(dia);
}

void* Robot::getModelFromColl()
{
  SoSeparator* root = NULL;
  switch (libs)
  {
    case IVPQP:
      root = new SoSeparator();
      for (unsigned int i = 0; i < links.size(); i++)
        root->addChild(((IVPQPElement*)links[i]->getElement())->getIvFromPQPModel());
      return (void*)root;
      break;
    case IVSOLID:
      root = new SoSeparator();
      for (unsigned int i = 0; i < links.size(); i++)
        root->addChild(((IVSOLIDElement*)links[i]->getElement())->getIvFromSOLIDModel());
      return (void*)root;
      break;
    default:
      return NULL;
  }
}

void Robot::control2Parameters(vector<KthReal> &control, vector<KthReal> &parameters)
{
  parameters.clear();
  if (robType == FREEFLY)
  {
    for (int i = 0; i < 6; i++)
      parameters.push_back((KthReal)0.0);
  }
  else
  {
    for (int i = 0; i < 6 + _currentConf.getRn().getDim(); i++)
      parameters.push_back((KthReal)0.0);
  }

  if (se3Enabled)
  {
    for (int i = 0; i < 6; i++)
    {
      for (unsigned int j = 0; j < control.size(); j++)
        parameters[i] += mapMatrix[i][j] * (control[j] - 0.5);
      parameters[i] += offMatrix[i];
    }
  }
  if (_currentConf.getRn().getDim() != 0)
  {
    for (int i = 0; i < _currentConf.getRn().getDim(); i++)
    {
      for (unsigned int j = 0; j < control.size(); j++) //{
        parameters[i + 6] += mapMatrix[i + 6][j] * (control[j] - 0.5);
      //cout << mapMatrix[i+6][j] << "\t" ;
      //}
      //cout << offMatrix[i+6];
      parameters[i + 6] += offMatrix[i + 6];
      //cout << endl;
    }
  }
}

void Robot::control2Pose(vector<KthReal> &values)
{
  vector<KthReal> vecTmp;
  _hasChanged = true;
  control2Parameters(values, vecTmp);
  parameter2Pose(vecTmp);
}

vector<KthReal> Robot::deNormalizeSE3(vector<KthReal> &values)
{
  std::vector<KthReal> coords(6);
  SE3Conf tmp;

  coords[0] = values[0] * (_homeLimits[0][1] - _homeLimits[0][0]) + _homeLimits[0][0];
  coords[1] = values[1] * (_homeLimits[1][1] - _homeLimits[1][0]) + _homeLimits[1][0];
  coords[2] = values[2] * (_homeLimits[2][1] - _homeLimits[2][0]) + _homeLimits[2][0];
  coords[3] = values[3];
  coords[4] = values[4];
  coords[5] = values[5];

  tmp.setCoordinates(coords); // It is the actual position but in the Home Frame

  mt::Point3 tempTran(tmp.getCoordinate(0), tmp.getCoordinate(1), tmp.getCoordinate(2));
  mt::Rotation tempRot(tmp.getCoordinate(3), tmp.getCoordinate(4), tmp.getCoordinate(5), tmp.getCoordinate(6));

  mt::Transform in_home, in_world;
  in_home.setRotation(tempRot);
  in_home.setTranslation(tempTran);

  in_world = _homeTrans * in_home;      // Obtaining it in the world frame.
  tempTran = in_world.getTranslation();
  tempRot = in_world.getRotation();

  coords.resize(7); // Resizing is needed to use quaternions
  coords[0] = tempTran[0];
  coords[1] = tempTran[1];
  coords[2] = tempTran[2];
  coords[3] = tempRot[0];
  coords[4] = tempRot[1];
  coords[5] = tempRot[2];
  coords[6] = tempRot[3];

  return coords;
}

//! This method maps between [0,1] parameter values to human readable values.
//! The values vector must have the controls size.
Conf& Robot::parameter2Conf(vector<KthReal> &values, CONFIGTYPE type)
{
  std::vector<KthReal> coords;
  switch (type)
  {
    case SE3:
      //  First, denormalize the SE3 configuration from 6 values in the Home frame.
      coords = deNormalizeSE3(values);
      _currentConf.setSE3(coords);
      return _currentConf.getSE3();
      break;
    case Rn:
      if (_currentConf.getRn().getDim() == values.size() - 6)
      {
        coords.resize(_currentConf.getRn().getDim());
        for (unsigned int i = 1; i < links.size(); i++)
          coords[i - 1] = ((Link*)links[i])->parameter2Value(values[i + 5]);

        _currentConf.setRn(coords);
        return _currentConf.getRn();
      }
  }
  throw exception();

}

//! This member function makes the movements needed to achieve the pose.
//! The vector values has the 6+Rn->getDim() size, in other words, the size
//! of this vector is all posible movements of any robot (SE3 + links).
void Robot::parameter2Pose(vector<KthReal> &values)
{
  if (armed /*&& numControls == values.size() */)
  {
    _hasChanged = true;
    if (se3Enabled)
    {
      // SE3 Denormalization in the wold frame
      vector<KthReal> coords = deNormalizeSE3(values);

      _currentConf.setSE3(coords);

      links[0]->getTransformation()->setTranslation(Point3(coords.at(0), coords.at(1), coords.at(2)));
      links[0]->getTransformation()->setRotation(Rotation(coords.at(3), coords.at(4), coords.at(5), coords.at(6)));
      links[0]->forceChange(NULL);

    }
    if (_currentConf.getRn().getDim() != 0)
    {
      // Rn denormalization
      vector<KthReal> coords(_currentConf.getRn().getDim());
      for (int i = 0; i < _currentConf.getRn().getDim(); i++)
      {
        links[i + 1]->setParameter(values[6 + i]);
        coords[i] = ((Link*)links[i + 1])->parameter2Value(values[i + 6]);
      }

      _currentConf.setRn(coords);
    }
    updateRobot();
  }
}

void Robot::updateRobot()
{
  for (unsigned int i = 0; i < links.size(); i++)
  {
    if (links[i]->changed())
    {
      links[i]->calculatePnO();
      _hasChanged = true;
    }
  }

  if (_attachedObject.size() != 0)
    moveAttachedObj();
}

bool Robot::setProposedSolution(vector<mt::Point3>& pathSE3)
{
  try
  {
    // Updating the graphical path if needed
    if (_graphicalPath != NULL)
      _graphicalPath->deleteValues(0);

    SbVec3f* temp = new SbVec3f[pathSE3.size()];
    vector<mt::Point3>::iterator it;
    unsigned int i = 0;
    for (it = pathSE3.begin(); it != pathSE3.end(); ++it)
    {
      temp[i].setValue((*it).at(0), (*it).at(1), (*it).at(2));
      ++i;
    }

    if (_graphicalPath != NULL)
      _graphicalPath->setValues(0, pathSE3.size(), temp);
    return true;
  }
  catch (...)
  {
    return false;
  }
}

bool Robot::setProposedSolution(vector<RobConf*>& path)
{
  try
  {
    unsigned int i = 0;
    _proposedSolution.clear();
    for (i = 0; i < path.size(); i++)
      _proposedSolution.push_back(*(path.at(i)));

    // Updating the graphical path if needed
    if (_graphicalPath != NULL)
      _graphicalPath->deleteValues(0);

    //if no need to draw path then return
    if (_linkPathDrawn < 0)
      return true;

    //else fill graphicalPath
    SbVec3f* temp = new SbVec3f[path.size()];

    vector<RobConf>::iterator it;
    mt::Point3 pos;
    mt::Transform trans;
    i = 0;
    for (it = _proposedSolution.begin(); it != _proposedSolution.end(); ++it)
    {
      Kinematics(*it);
      trans = getLinkTransform(_linkPathDrawn); //draws the path of link number linkPathDrawn
      //trans = getLastLinkTransform();
      pos = trans.getTranslation();
      temp[i].setValue(pos.at(0), pos.at(1), pos.at(2));
      ++i;
    }
    if (_graphicalPath != NULL)
      _graphicalPath->setValues(0, path.size(), temp);
    delete[] temp;
    return true;
  }
  catch (...)
  {
    return false;
  }
}

bool Robot::cleanProposedSolution()
{
  try
  {
    _proposedSolution.clear();
    if (_graphicalPath != NULL)
      _graphicalPath->deleteValues(0);
    return true;
  }
  catch (...)
  {
    return false;
  }
}

bool Robot::setPathVisibility(bool visible)
{
  bool response = false;
  SoNode *sepgrid = NULL;
  try
  {
    if (visible)
    {
      //sepgrid = ((SoSeparator*)visModel)->getByName("Path");
      //if( sepgrid == NULL ) // It is OK, they is not attached to the root.
      ((SoSeparator*)visModel)->addChild(_pathSeparator);

      response = true;
    }
    else
    {
      sepgrid = ((SoSeparator*)visModel)->getByName("Path");
      if (sepgrid != NULL)
      {
        ((SoSeparator*)visModel)->removeChild(sepgrid);
        //sepgrid->unref();
      }

      response = false;
    }
  }
  catch (...)
  {
  }

  return response;
}
}

