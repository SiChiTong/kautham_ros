/***************************************************************************
 *               Generated by StarUML(tm) C++ Add-In                        *
 ***************************************************************************/
/***************************************************************************
 *                                                                          *
 *           Institute of Industrial and Control Engineering                *
 *                 Technical University of Catalunya                        *
 *                        Barcelona, Spain                                  *
 *                                                                          *
 *                Project Name:       Kautham Planner                       *
 *                                                                          *
 *     Copyright (C) 2007 - 2011 by Alexander Pérez and Jan Rosell          *
 *            alexander.perez@upc.edu and jan.rosell@upc.edu                *
 *                                                                          *
 *             This is a motion planning tool to be used into               *
 *             academic environment and it's provided without               *
 *                     any warranty by the authors.                         *
 *                                                                          *
 *          Alexander Pérez is also with the Escuela Colombiana             *
 *          de Ingeniería "Julio Garavito" placed in Bogotá D.C.            *
 *             Colombia.  alexander.perez@escuelaing.edu.co                 *
 *                                                                          *
 ***************************************************************************/
/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 ***************************************************************************/

#if !defined(_ROBOT_H)
#define _ROBOT_H

#include "obstacle.h"
#include "link.h"
#include <mt/transform.h>
#include <libsampling/robconf.h>
//#include <Inventor/VRMLnodes/SoVRMLExtrusion.h>
#include "inversekinematic.h"
#include "constrainedkinematic.h"
#include <list>

using namespace std;

//class InverseKinematic;

namespace libProblem
{
struct attObj
{
  attObj()
  {
    obs = NULL;
    link = NULL;
  }
  ~attObj()
  {
    obs = NULL;
    link = NULL;
  }
  Obstacle* obs;
  Link* link;
  mt::Transform trans;
  bool toLink(string linkName)
  {
    return link->getName() == linkName;
  }

  bool collisionCheck(Obstacle *obs)
  {

    if (obs->getEnableCollisions() == false)
      return false; //transparent obstacle...

    if (obs->getElement()->collideTo(obs->getElement()))
      return true;

    return false;
  }
};

class Robot
{
public:
  Robot(string robFile, KthReal scale, LIBUSED lib = IVPQP);

  Link* getLink(unsigned int i);
  Link* getLinkByName(string linkName);

  bool autocollision(int t = 0);

  //! This method builds the link model and all their data structures in order
  //! to keep the coherence in the robot assembly. It doesn't use any intermediate
  //! structure to adquire the information to do the job.
  bool addLink(string name, string ivFile, KthReal theta, KthReal d, KthReal a, KthReal alpha, bool rotational,
               bool movable, KthReal low, KthReal hi, KthReal w, string parentName, KthReal preTrans[] = NULL);

//    //! This method is deprecated because It uses the DATA intermediate structure.
//    //! Please don't use it and take care with your Rob file to define the robot correctly.
//	  bool addLink(string name, string ivFile, KthReal theta, KthReal d, KthReal a,
//                 KthReal alpha, bool rotational, bool movable, KthReal low,
//                 KthReal hi,  KthReal w, string parentName, DATA *preTrans = NULL);

  //!	This member function set the robot name.
  inline void setName(string nam)
  {
    name = nam;
  }

  inline string getName() const
  {
    return name;
  }

  //! It sets the robot to the pose bring by the robq parameter.
  bool Kinematics(RobConf *robq);

  bool Kinematics(RobConf& robq);

  bool Kinematics(SE3Conf& q);

  bool Kinematics(RnConf& q);

  //!	This method uses the Configuration q to set up the position, orientation,
  //!	and articular values if the robot has one. If the configuration q is SE2 or SE3
  //!	the robot change the position and/or orientation either the configuration is
  //!	Rn the robot change the articular values.
  bool Kinematics(Conf *q);

  // This member method is the interface to calling the inverse kinematic
  //   object associated. It returns the RobConf<SE3Conf,RnConf> configuration
  //   that describe the pose of the robot completely.
  //
  RobConf& InverseKinematics(vector<KthReal> &target);

  /** This member method is another interface to calling the inverse kinematic
   *   object associated. It returns the RobConf<SE3Conf,RnConf> configuration
   *   that describe the pose of the robot completely.
   */
  RobConf& InverseKinematics(vector<KthReal> &target, vector<KthReal> masterconf, bool maintainSameWrist);

  void setHomePos(Conf* qh);

  void setInitPos(Conf *qi);

  void setGoalPos(Conf *qg);

  //! This method returns the current RobConf used to
  //! represent the SE3 position and Rn configuration
  inline RobConf* getCurrentPos()
  {
    return &_currentConf;
  }

  inline RobConf* getInialPos()
  {
    return &_initConf;
  }

  inline RobConf* getGoalPos()
  {
    return &_goalConf;
  }

  inline RobConf* getHomePos()
  {
    return &_homeConf;
  }

  bool collisionCheck(Obstacle *obs);

  bool collisionCheck(Robot *rob);

  KthReal distanceCheck(Obstacle *obs, bool min = true);

  KthReal distanceCheck(Robot *rob, bool min = true);

  bool setLimits(int member, KthReal min, KthReal max);

  void* getModel();

  void* getModelFromColl();

  //! This method makes the mapping between control values and configurations.
  //! The method receives the values and it makes the changes in respective configurations
  //! If the robot is freeflying only changes the SE3/SE2 Conf corresponding to
  //! position and orientation of it using the Kinematics methods, but if the robot
  //! is a chain or a tree robot, this method changes a SE3/SE2 Conf (position
  //! and orientation) and a Rn Conf for articular values. All values are between 0 and 1.
  void control2Pose(vector<KthReal> &values);

  //! This method maps the values of position/pose of robot taking into account the movement
  //! limits.
  Conf& parameter2Conf(vector<KthReal> &values, CONFIGTYPE type);

  //! This method returns the type of libraries used to build the models.
  inline LIBUSED whatLibs()
  {
    return libs;
  }

  inline KthReal* getLimits(int member)
  {
    return _spatialLimits[member];
  }

  //!	This member function returns the robot type.
  //!	This member function returns the robot type, in this case it returns a
  //	FREEFLY constant. For compatibility with other robot types.
  inline ROBOTTYPE getRobotType()
  {
    return robType;
  }

  //!	This member funcion set a robot type.
  //!	This member funcion set a robot type, in this case is FREEFLY constant
  //		For compatibility with other type of robots.
  inline void setRobotType(ROBOTTYPE rob)
  {
    robType = rob;
  }

  //!	This member funcion return a problem type.
  //!	This member funcion return a problem type. For freefling robots, it can
  //	be SE2, SE3, R2 or R3.
  //inline CONFIGTYPE getProblemType(){return probType;}

  //!	This member funcion set a problem type.
  //!	This member funcion set a problem type.  For freefling robots, it can
  //	be SE2, SE3, R2 or R3.
  //inline void setProblemType(CONFIGTYPE pT){probType = pT;}

  inline KthReal getScale() const
  {
    return scale;
  }

  inline int getTrunk() const
  {
    return nTrunk;
  }

  inline KthReal* getWeightSE3()
  {
    KthReal tmp = 1.;
    if (_weights != NULL)
      return _weights->getSE3Weight();
    else
      throw exception();
  }

  inline vector<KthReal>& getWeightRn()
  {
    if (_weights != NULL)
      return _weights->getRnWeights();
    else
      throw exception();
  }

  RobWeight* getRobWeight()
  {
    return _weights;
  }

  inline void setDHApproach(DHAPPROACH dhA)
  {
    dhApproach = dhA;
  }

  inline DHAPPROACH getDHApproach()
  {
    return dhApproach;
  }

  //!	This fuction return the joint number that compose the Robot.
  inline unsigned int getNumJoints()
  {
    return ((unsigned int)links.size()) - 1;
  }

  //!	This fuction return the link number that compose the Robot.
  inline unsigned int getNumLinks()
  {
    return (unsigned int)links.size();
  }

  void parameter2Pose(vector<KthReal> &values);

  void control2Parameters(vector<KthReal> &control, vector<KthReal> &parameters);

  inline bool isSE3Enabled() const
  {
    return se3Enabled;
  }
  bool setInverseKinematic(INVKINECLASSES type);
  bool setInverseKinematicParameter(string name, KthReal value);
  InverseKinematic* getIkine()
  {
    return _ikine;
  }

  // \brief This method defines the control and the offset matrixes.
  //   Keep in mind that the control are values between [-0.5,0.5]
  //   meanwhile the normalized configuration are values between
  //   [0, 1] for this reason in the SE3 freeflying robots the offset
  //   matrix should be forced to be 0.5.

  //void setControls(xml_document &doc = xml_document);

  bool setControlItem(string control, string dof, KthReal value);

  inline string getControlsName() const
  {
    return controlsName;
  }
  string getDOFNames();

  inline int getNumControls()
  {
    if (armed)
      return numControls;
    return -1;
  }

  inline mt::Transform& getLastLinkTransform()
  {
    return *(((Link*)links.at(links.size() - 1))->getTransformation());
  }

  inline mt::Transform& getLinkTransform(unsigned int numLink)
  {
    if (numLink < 0 || numLink >= links.size())
      numLink = links.size() - 1;
    return *(((Link*)links.at(numLink))->getTransformation());
  }

  inline mt::Transform& getHomeTransform()
  {
    return *(links[0]->getTransformation());
  }
  bool setProposedSolution(vector<mt::Point3>& pathSE3);
  bool setProposedSolution(vector<RobConf*>& path);
  bool cleanProposedSolution();

  //! This method returns the Proposed Solution as a vector of RobConf that may be used to guide
  //! the user.
  inline vector<RobConf>& getProposedSolution()
  {
    return _proposedSolution;
  }
  inline void setLinkPathDrawn(int n)
  {
    _linkPathDrawn = n;
  }
  bool setConstrainedKinematic(CONSTRAINEDKINEMATICS type);
  bool setConstrainedKinematicParameter(string name, KthReal value);
  ConstrainedKinematic* getCkine()
  {
    return _constrainKin;
  }
  RobConf& ConstrainedKinematics(vector<KthReal> &target);
  bool setPathVisibility(bool visible);

  //! This method attaches an existing obstacle to the link specified by the linkName parameter.
  //! This method
  bool attachObject(Obstacle* obs, string linkName);

  //! This method moves the attached object to the robot. The object can be attached to any link
  //! of the robot. This method processes the _attachedObj list to calculated the new position and
  //! orientation based on the position and orientation of the robot link where the object is attached
  //! and the mt::Transform calculated on the attached instant.
  void moveAttachedObj();

  //! This method detaches the previously attached objects to the link named linkName.
  bool detachObject(string linkName);

  inline unsigned getNumAttachedObj()
  {
    return _attachedObject.size();
  }
  //inline list<attObj>::iterator    getItAttachedObj(){return _attachedObject.begin();}

  list<attObj> _attachedObject;

private:
  //! This method updates the absolute position and orientation of each link in the robot.
  void updateRobot();

  //! This method recalculates the limits in the home frame to be used in the de-normalization
  //! of the mapping between the controls and the absolute SE3 position.
  void recalculateHomeLimits();

  //! This method denormalizes the SE3 unit representation and returns the positon and the
  //! rotation (quaternion) in a single vector.
  vector<KthReal> deNormalizeSE3(vector<KthReal> &values);

  //void              setRobotWeights(RobotParse *parser);

  float diagLimits();

  ROBOTTYPE robType;
  LIBUSED libs;

  RobConf _homeConf;     //!< This attribute is the Home configuration of the robot.
  RobConf _initConf;     //!< This attribute is the initial configuration of the robot planning problem.
  RobConf _goalConf;     //!< This attribute is the goal configuration of the robot planning problem.
  RobConf _currentConf;  //!< This attribute is the current configuration of the robot.

  KthReal _spatialLimits[7][2];
  KthReal _homeLimits[7][2];

  //!	This Vector contains pointers to each Link
  /*!	This method begins with the Link base and it ends with the location of final effector.
   *  In case of Tree robots, each branch is inserted sequentially
   */
  vector<Link*> links;

  //!	This attribute show if the Robot is complete or still is under construction.
  bool armed;

  //!	It is a descriptive name of robot
  string name;

  //! This is the global scale for all the links that compound the robot.
  //! Normally it is equal to one.
  KthReal scale;

  DHAPPROACH dhApproach;    //! It identifies the D-H description method (Standar/Modified).

  //! This attribute is true if the robot is not freeflying and it could be moved.
  bool se3Enabled;

  //! weight between translational and rotational components in distance computations
  //KthReal           _weightSE3;
  RobWeight* _weights;

  //! This is the transformation used to calculate the spatial limits into the home
  //! frame in order to preserve the home ubication at time zero.
  mt::Transform _homeTrans; //!< This is the Home Reference frame at time zero.

  void* visModel;
  KthReal *offMatrix;
  KthReal **mapMatrix;
  string controlsName;
  int numControls;  //!> This is the number of control used to command the robot
  bool _autocoll;
  bool _hasChanged;
  int nTrunk; //!> Number of control for the trunk in case of TREE robot
  InverseKinematic* _ikine;
  ConstrainedKinematic* _constrainKin;
  vector<RobConf> _proposedSolution;
  SoMFVec3f* _graphicalPath; //!> This corresponds to translational part of the last link absolute path.
  SoSeparator* _pathSeparator;
  int _linkPathDrawn; //!> This is the number of the link whose path will be drawn
  //list<attObj>      _attachedObject;
};
}

#endif  //_ROBOT_H
