/***************************************************************************
*               Generated by StarUML(tm) C++ Add-In                        *
***************************************************************************/
/***************************************************************************
*                                                                          *
*           Institute of Industrial and Control Engineering                *
*                 Technical University of Catalunya                        *
*                        Barcelona, Spain                                  *
*                                                                          *
*                Project Name:       Kautham Planner                       *
*                                                                          *
*     Copyright (C) 2007 - 2009 by Alexander Pérez and Jan Rosell          *
*            alexander.perez@upc.edu and jan.rosell@upc.edu                *
*                                                                          *
*             This is a motion planning tool to be used into               *
*             academic environment and it's provided without               *
*                     any warranty by the authors.                         *
*                                                                          *
*          Alexander Pérez is also with the Escuela Colombiana             *
*          de Ingeniería "Julio Garavito" placed in Bogotá D.C.            *
*             Colombia.  alexander.perez@escuelaing.edu.co                 *
*                                                                          *
***************************************************************************/
/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 ***************************************************************************/
 
  
#include <Inventor/Qt/SoQt.h>
#include <QFile>
#include <QString>
#include <QMessageBox>
#include <sstream>
#include <libproblem/ivworkspace.h>
#include <mt/transform.h>

#include <libutil/kauthamdefs.h>
#include "application.h"

#include "ros/ros.h"
#include "math.h"

#include "libproblem/problem.h"
#include "libplanner/kthquery.h"

#include "trajectory_msgs/JointTrajectory.h"
#include "trajectory_msgs/JointTrajectoryPoint.h"

#include "kautham_ros/ReqPlan.h"
#include "kautham_ros/ReqCollisionCheck.h"
#include "kautham_ros/ReqQuery.h"
#include "kautham_ros/MoveRobots.h"
#include "kautham_ros/ProblemSetup.h"
#include "kautham_ros/Forbidden.h"
#include "kautham_ros/SolveProblem.h"
#include "kautham_ros/AttObj.h"
#include "kautham_ros/DetObj.h"

#include "kautham_ros/SaveData.h"
#include "kautham_ros/LoadData.h"

#include "kautham_ros/empty.h"

using namespace libProblem;
using namespace libPlanner;

Application::Application() { 
  Q_INIT_RESOURCE(kauthamRes);
  initApp();

  timerUpdate = new QTimer(this);
  connect(timerUpdate, SIGNAL(timeout()), this, SLOT(rosUpdate()));
  timerUpdate->start(100);

}

void Application::initApp(){
  mainWindow = new GUI();
  SoQt::show(mainWindow);
  setActions();
  mainWindow->setText("Open a problem file to start...");
  appState = INITIAL ;
  _problem = NULL;
}

Application::~Application() {

}

void Application::setActions(){
  mainWindow->setAction(FILETOOL,"&Open","CTRL+O",":/icons/fileopen.xpm",this,SLOT(openFile()));
  mainWindow->addSeparator(TOOLBAR);

  mainWindow->setAction(FILETOOL,"&Close","CTRL+Q",":/icons/close.xpm",this,SLOT(closeProblem()));
  mainWindow->addSeparator(TOOLBAR);
  mainWindow->setAction(ACTIONTOOL,"Chan&ge Colour","CTRL+G",
                                ":/icons/determ.xpm", mainWindow, SLOT(changeActiveBackground()));
}

void Application::openFile(){
  QString path,dir;
  QDir workDir;
  mainWindow->setCursor(QCursor(Qt::WaitCursor));

  switch(appState){
    case INITIAL:
      path = QFileDialog::getOpenFileName(  mainWindow,
                                            "Choose a file to open",
                                            workDir.absolutePath(),
                                            "All configuration files (*.xml)");
      if(!path.isEmpty()){
        mainWindow->setText("Kautham is opening a problem file...");
        dir = path;
        dir.truncate(dir.lastIndexOf("/"));
        problemSetup(path.toUtf8().constData());
        stringstream tmp;
        tmp << "Kautham ";
        tmp << MAJOR_VERSION;
        tmp << ".";
        tmp << MINOR_VERSION;
        tmp << " - ";
        tmp << path.toUtf8().constData();
        mainWindow->setWindowTitle( tmp.str().c_str() );
        mainWindow->setText(QString("File: ").append(path).toUtf8().constData() );
	mainWindow->setText("opened successfully.");
      }
      break;
    case PROBLEMLOADED:
      break;
    default:
      break;
  }

  mainWindow->setCursor(QCursor(Qt::ArrowCursor));
}

void Application::closeProblem(){
  mainWindow->setCursor(QCursor(Qt::WaitCursor));
  switch(appState){
  case INITIAL:
    mainWindow->setText("First open a problem");
    break;
  case PROBLEMLOADED:
    mainWindow->restart();
    delete _problem;
    appState = INITIAL;
    break;
  }
  mainWindow->setCursor(QCursor(Qt::ArrowCursor));
}

void Application::rosUpdate(){

  ros::spinOnce();
}

//bool Application::SrvMoveRobot(kautham_ros::MoveRobot::Request  &req,
//                                       kautham_ros::MoveRobot::Response &res){
//
//  //ToDo: generalizar para n robots diferentes
//
//  unsigned Robot0Dim = _problem->wSpace()->getRobot(req.Robot)->getNumControls();
//  vector<KthReal> poseR0(Robot0Dim);
//
//  unsigned Robot1Dim = _problem->wSpace()->getRobot(req.Robot)->getNumControls();
//  vector<KthReal> poseR1(Robot1Dim);
//
//  vector<KthReal> pose(_dim);
//
//  if ( req.Robot == 0){
//    // Pose to robot 0
//    for (unsigned i = 0; i < Robot0Dim; i++){
//      poseR0[i] = req.Pose.positions[i];
//      //cout << req.Pose.positions[i] << " ";
//    }
//    //Pose to robot 1
//    poseR1 = _problem->wSpace()->getRobot( 1 )->getCurrentPos()->getRn().getCoordinates();
//
//  }else{ // req.Robot == 1
//
//    //Pose to robot 0
//    poseR0 = _problem->wSpace()->getRobot( 0 )->getCurrentPos()->getRn().getCoordinates();
//
//    // Pose to robot 1
//    for (unsigned i = 0; i < Robot1Dim; i++){
//      poseR1[i] = req.Pose.positions[i];
//      //cout << req.Pose.positions[i] << " ";
//    }
//  }
//
//  //Total pose
//  for (unsigned i = 0;i < Robot0Dim; i++)
//          pose[i] = poseR0[i];
//  for (unsigned i = 0;i < Robot1Dim; i++)
//          pose[i+Robot0Dim] = poseR1[i];
//
//
//  Sample* smp = new Sample(_dim);
//  smp->setCoords( pose );
//  _problem->wSpace()->moveRobotsTo( smp );
//
//  //ROS_INFO("Moving Robots...");
//  return true;
//}

bool Application::problemSetup(string path){
  mainWindow->setCursor(QCursor(Qt::WaitCursor));

  _problem = new Problem();
  LoadedSamples = false;

  if( _problem->setupFromFile( path ) ){
      cout << "The problem file has been loaded successfully.\n";

      // Configuring the problem from information on file
      _planner = _problem->getPlanner();
      _samples = _problem->getSampleSet();
      _dim =  _samples->getSampleAt(0)->getDim();

      init_sample = _samples->getSampleAt(0)->getCoords();

      fillGraspPosesInfo();

      Sample *tsmp = new Sample(_dim);
      tsmp->setCoords(init_sample);
      _problem->wSpace()->moveRobotsTo( tsmp );

      mainWindow->addViewerTab("WSpace", libGUI::SPACE, ((IVWorkSpace*)_problem->wSpace())->getIvScene());

      appState = PROBLEMLOADED;
      mainWindow->setCursor(QCursor(Qt::ArrowCursor));

      return true;
  }
  else{
    cout << "Problem loading file..." << endl;
    delete _problem;
  }

return false;
}
/****************************************************************************************************/

bool Application::fillGraspPosesInfo( void ){

  // Fill the graspPoses vector for CAN and SAH
  vector< float > dummy(7);

  dummy.push_back(0.0);
  dummy.push_back(1.0);
  dummy.push_back(0.0);
  dummy.push_back(0.0);
  dummy.push_back(-70.0);
  dummy.push_back(10.0);
  dummy.push_back(-220.0);

  graspPosesSAH_CAN.push_back(dummy);
  dummy.resize(0);

  dummy.push_back(0.0);
  dummy.push_back(1.0);
  dummy.push_back(0.0);
  dummy.push_back(0.79);
  dummy.push_back(-206.0);
  dummy.push_back(10.0);
  dummy.push_back(-105.0);

  graspPosesSAH_CAN.push_back(dummy);
  dummy.resize(0);

  dummy.push_back(0.0);
  dummy.push_back(1.0);
  dummy.push_back(0.0);
  dummy.push_back(1.57);
  dummy.push_back(-220.0);
  dummy.push_back(10.0);
  dummy.push_back(70.0);

  graspPosesSAH_CAN.push_back(dummy);
  dummy.resize(0);

  dummy.push_back(0.0);
  dummy.push_back(1.0);
  dummy.push_back(0.0);
  dummy.push_back(2.36);
  dummy.push_back(-105.0);
  dummy.push_back(10.0);
  dummy.push_back(206.0);

  graspPosesSAH_CAN.push_back(dummy);
  dummy.resize(0);

  dummy.push_back(0.0);
  dummy.push_back(1.0);
  dummy.push_back(0.0);
  dummy.push_back(3.1415);
  dummy.push_back(70.0);
  dummy.push_back(10.0);
  dummy.push_back(220.0);

  graspPosesSAH_CAN.push_back(dummy);
  dummy.resize(0);

  dummy.push_back(0.0);
  dummy.push_back(1.0);
  dummy.push_back(0.0);
  dummy.push_back(3.93);
  dummy.push_back(206.0);
  dummy.push_back(10.0);
  dummy.push_back(105.0);

  graspPosesSAH_CAN.push_back(dummy);
  dummy.resize(0);

  dummy.push_back(0.0);
  dummy.push_back(1.0);
  dummy.push_back(0.0);
  dummy.push_back(4.71);
  dummy.push_back(220.0);
  dummy.push_back(10.0);
  dummy.push_back(-70.0);

  graspPosesSAH_CAN.push_back(dummy);
  dummy.resize(0);

  dummy.push_back(0.0);
  dummy.push_back(1.0);
  dummy.push_back(0.0);
  dummy.push_back(5.5);
  dummy.push_back(105.0);
  dummy.push_back(10.0);
  dummy.push_back(-206.0);

  graspPosesSAH_CAN.push_back(dummy);
  dummy.resize(0);

  return true;
}

bool Application::SrvProblemSetup(kautham_ros::ProblemSetup::Request &req,
                     kautham_ros::ProblemSetup::Response &res){

  ROS_INFO("Service Problem setup launched");

  if (problemSetup( req.problem.data )){
      res.status = true;
      res.dim = _dim;
    }
    else{
      res.status = false;
      res.dim = 0;
    }

    handType = req.hand;

    // ToDo: Debe ser un servicio?
    setObstaclesNames( );

    return true;
}

bool Application::solveProblem( std::string path ){

  if (_problem != NULL){
    delete _problem;
  }

  _problem = new Problem();

  // Opening the problem from file
  if( _problem->setupFromFile( path ) ){
    cout << "The problem file has been loaded successfully.\n";

    // Configuring the problem from information on file
    _planner = _problem->getPlanner();
    _samples = _problem->getSampleSet();
    _dim =  _samples->getSampleAt(0)->getDim();

    vector<KthReal> init( _samples->getSampleAt(0)->getCoords());
    vector<KthReal> goal( _samples->getSampleAt(1)->getCoords());

    _samples->clear();

    Sample* smp = new Sample(_dim);
    smp->setCoords( init );
    _samples->add( smp );
    smp = new Sample(_dim);
    smp->setCoords( goal );
    _samples->add( smp );

    _planner->setInitSamp( _samples->getSampleAt(0) );
    _planner->setGoalSamp( _samples->getSampleAt(1) );
  }
  else{
    std::cout << "The problem file has not been loaded successfully. "
              << "Please take care with the problem definition.\n";
    ROS_INFO(" Error in problem file ");
    return false;
  }

  if(_planner->solveAndInherit()){
    //KthQuery& tmp = _planner->getQueries().at( _planner->getQueries().size() - 1 );

    _SolutionPlan = _planner->getSimulationPath();

    vector<double> positions(_dim, 0);

    _points.resize(_SolutionPlan->size());

    for ( unsigned j = 0; j < _SolutionPlan->size() ; j++ ){
      //std::cout << "Sample " << j << ": ";
      for ( unsigned i = 0; i < _dim; i++ ){
        positions[i] = _SolutionPlan->at(j)->getCoords().at(i);
        //std::cout << positions[i] << " ";
      }

      //std::cout << std::endl;
      _points[j].positions = positions;
    }
    return true;
  }
  else
    return false;

}

bool Application::SrvReqPlan(kautham_ros::ReqPlan::Request  &req,
                                kautham_ros::ReqPlan::Response &res)
{
  ROS_INFO("SrvReqPlan launched for %s", req.problem.data.c_str());

  solveProblem( req.problem.data );

  res.plan.points = _points;

  return true;
}

bool Application::SrvCollisionCheck(kautham_ros::ReqCollisionCheck::Request  &req,
                                       kautham_ros::ReqCollisionCheck::Response &res)
{
  ROS_INFO("SrvCollisionCheck launched. Problem dimension: %d", _dim);

  vector<KthReal> pose;
  pose.resize(_dim,0);

  for (unsigned i = 0; i < _dim; i++)
          pose[i] = req.pose.positions[i];

  Sample* smp = new Sample(_dim);
  smp->setCoords( pose );

  if (_problem->wSpace()->collisionCheck( smp ))
    res.collision = true;
  else{
          //_problem->wSpace()->moveTo( smp );
          res.collision = false;
  }

  return true;
}

bool Application::SrvSolveQuery(kautham_ros::ReqQuery::Request &req,
                                   kautham_ros::ReqQuery::Response &res)
{
  ROS_INFO("SrvSolveQuery launched");

  bool sampleschanged = false;

  if (!LoadedSamples){
    _samples->clear();
  }

  vector<KthReal> samp;
  samp.resize(_dim);

  // Copy Init sample from request
  cout << "Init sample: ";
  for (unsigned i = 0; i < _dim; i++){
    samp[i] = req.Init.positions[i];
  cout << samp[i] << " ";
  }
  cout << endl;

  // Set Init Sample to planner
  Sample* smp = new Sample(_dim);
  smp->setCoords( samp );

  cout << "Index of sample init: " << _samples->indexOf( smp ) << endl;
  if ( _samples->indexOf( smp ) == _samples->getSize()){
    _samples->add( smp );

    cout << "Sample: ";
    for (unsigned s = 0; s < smp->getCoords().size(); s++){
      cout << smp->getCoords().at(s) << " ";
    }
    cout << endl;

    sampleschanged = true;
  }

  _planner->setInitSamp( smp );

  // Copy goal sample from request
  cout << "Goal sample: ";
  for (unsigned i = 0; i < _dim; i++){
    samp[i] = req.Goal.positions[i];
    cout << samp[i] << " ";
  }
  cout << endl;

  // Set goal sample to planner
  smp = new Sample(_dim);
  smp->setCoords( samp );

  cout << "Index of sample goal: " << _samples->indexOf( smp ) << endl;
  if ( _samples->indexOf( smp ) == _samples->getSize())
  {
    _samples->add( smp );

    cout << "Sample: ";
    for (unsigned s = 0; s < smp->getCoords().size(); s++){
      cout << smp->getCoords().at(s) << " ";
    }
    cout << endl;
    sampleschanged = true;
  }

  _planner->setGoalSamp( smp );

  // Call to trysolve
  if(_planner->solveAndInherit()){

        // Copy simulation plan solution
    _SolutionPlan = _planner->getSimulationPath();

    cout << "Plan for Query with " << _SolutionPlan->size() << " points" << endl;
    _points.resize(_SolutionPlan->size());

    vector<double> positions(_dim, 0);

    // Copy all the points in solution
    for ( unsigned j = 0; j < _SolutionPlan->size() ; j++ ){
      for ( unsigned i = 0; i < _dim; i++ ){
        positions[i] = _SolutionPlan->at(j)->getCoords().at(i);
      }
      _points[j].positions = positions;
    }

    // Set response to service call
    res.plan.points = _points;
    res.status = true;

    if (sampleschanged){
      _planner->saveData(filepath);
      cout << "Saving Data file in Query..." << endl;
    }

    return true;
  }
  else{
        ROS_INFO("Plan without solution...");
        res.status = false;
  }

  return false;

}

bool Application::SrvMoveRobots(kautham_ros::MoveRobots::Request  &req,
                   kautham_ros::MoveRobots::Response &res){

  vector<KthReal> pose(_dim);

  for (unsigned i = 0; i < _dim; i++){
    pose[i] = req.Pose.positions[i];
  }

  Sample* smp = new Sample(_dim);
  smp->setCoords( pose );
  _problem->wSpace()->moveRobotsTo( smp );

  //getTransformation();

  //ROS_INFO("Moving Robots...");
  return true;
}

bool Application::getTransformation(){

  cout << _problem->wSpace()->getRobot(0)->getHomeTransform();

  return true;
}

bool Application::setObstaclesNames( void ){

  // Configure the obstacles names. Necessary fir Inverse Kinematic.
  unsigned int itObst = 0;

  //_problem->wSpace()->_forbiddenObstacles.push_back(itObst);
  _problem->wSpace()->getObstacle(itObst++)->setName("ioc");
  //_problem->wSpace()->_forbiddenObstacles.push_back(itObst);
  _problem->wSpace()->getObstacle(itObst++)->setName("table");
  //_problem->wSpace()->_forbiddenObstacles.push_back(itObst);
  _problem->wSpace()->getObstacle(itObst++)->setName("cangoal");

  // Another obstacles...
  for (;itObst < _problem->wSpace()->obstaclesCount(); itObst++)
    _problem->wSpace()->getObstacle(itObst)->setName("can");

  return true;
}

bool Application::ArmInverseKinematics( unsigned int Robot, vector<KthReal> &carm ){

  RobConf rc;
  //SE3Conf c;
  std::vector<KthReal> tmpcoordTCP; tmpcoordTCP.resize(7);

  for(int k=0;k<7;k++) tmpcoordTCP[k] = carm[k];
  //c.setCoordinates(tmpcoordTCP);

  try{
    rc = _problem->wSpace()->getRobot(Robot)->InverseKinematics( tmpcoordTCP );
  }catch(InvKinEx &ex){
//    std::cout << ex.what() << std::endl;
    return false;
  }

  //load the six joint values of the arm
  for(int k=0;k<6;k++)
    carm[k] = rc.getRn().getCoordinate(k);

  KthReal low[6];
  KthReal high[6];
  for(int k=0; k < 6; k++){
    //normalize
    low[k] = *_problem->wSpace()->getRobot(Robot)->getLink(k+1)->getLimits(true);
    high[k] = *_problem->wSpace()->getRobot(Robot)->getLink(k+1)->getLimits(false);
    carm[k] = floorf((carm[k]-low[k])/(high[k]-low[k]) * 1000) / 1000;

  }

  return true;
}

// Function takes an object (numObject), and test if a Position of the hand (Position) is reachable
// using the inverse kinematic.
// Return true and a sample (smp) if the object with the position is graspable.
bool Application::isGraspableObject( int numObject, std::vector<float> Position,  Sample &smp){

  float *goalPosition = _problem->wSpace()->getObstacle( numObject )->getElement()->getPosition();
  float *goalOrientation = _problem->wSpace()->getObstacle( numObject )->getElement()->getOrientation();

  // Obtain the transformation relative to Object
  mt::Point3 pGoal(goalPosition);
  mt::Rotation rGoal(goalOrientation);
  mt::Transform T1(rGoal, pGoal);

  mt::Unit3 axis(Position.at(0), Position.at(1), Position.at(2));
  mt::Scalar angle = Position.at(3);
  mt::Rotation rot(axis, angle);
  mt::Point3 tr(Position.at(4), Position.at(5), Position.at(6));

  mt::Transform T2(rot, tr);

  mt::Transform Tfinal = T1 * T2;

  vector<KthReal> cords(7);

  mt::Rotation nrot = Tfinal.getRotation();
  mt::Point3 ntr = Tfinal.getTranslation();

  cords[0] = ntr.at(0);
  cords[1] = ntr.at(1);
  cords[2] = ntr.at(2);
  cords[3] = nrot.at(0);
  cords[4] = nrot.at(1);
  cords[5] = nrot.at(2);
  cords[6] = nrot.at(3);

  bool invKinSolved = ArmInverseKinematics( 0, cords );

  // Include hand configuration
  cords.resize(_dim);
  cords[6] = 0.0;
  cords[7] = 0.757;

  if ( invKinSolved == true ){

    // Testing code, to visualize the robot. Must be removed in the code
    //Collision with Non movable Obstacles
    Sample* tsmp = new Sample (_dim);
    tsmp->setCoords( cords );

    smp = tsmp;

    return true;
  }

  return false;
}

bool Application::testGrasp( unsigned Obstgoal ){

  //ToDo: solo tiene en cuenta el brazo...

  // Clear graspInfo
  graspInfo.clear();
  tmpGrasp.distance.clear();
  tmpGrasp.graspSmp.clear();

  vector<float> grasp(7);
  KthReal distToInit;

  Sample * Init = new Sample (_dim);
  Init->setCoords( init_sample );

  Obstacle* Obst = _problem->wSpace()->getObstacle( Obstgoal );

  tmpGrasp.goal = Obstgoal;

  if( Obst->getName() ==  "cangoal" || Obst->getName() ==  "can"){

      if ( handType == SAH ){

        for (unsigned it = 0; it < graspPosesSAH_CAN.size(); it++){

          // fill the grasp relative position
          grasp = graspPosesSAH_CAN.at( it );

          Sample* grasp_smp = new Sample(_dim);

          if( isGraspableObject( Obstgoal, grasp, *grasp_smp ) ){

            if (!_problem->wSpace()->collisionCheck( grasp_smp ) ){

              tmpGrasp.graspSmp.push_back(grasp_smp->getCoords());

              distToInit = _problem->wSpace()->distanceBetweenSamples(*grasp_smp, *Init, CONFIGSPACE);
              tmpGrasp.distance.push_back( distToInit );

              cout << "Grasp: ";
              for (unsigned i = 0;i < _dim;i++){
                cout << tmpGrasp.graspSmp.at(tmpGrasp.graspSmp.size()-1).at(i) << " ";
              }
              cout << endl << "Distance: " << distToInit << endl;
            }
          }
        }
      }
      else{ //handType == SDH

      }
  }else{// Bricks

  }

  std::vector< float > tmp_smp(_dim);
  float tmp_dist;

  for (unsigned i = 1; i < tmpGrasp.graspSmp.size(); i++){
    for (unsigned j = 0; j < tmpGrasp.graspSmp.size() - i; j++){

      if ( tmpGrasp.distance.at(j) > tmpGrasp.distance.at(j+1) ){

        tmp_smp = tmpGrasp.graspSmp.at(j);
        tmpGrasp.graspSmp.at(j) = tmpGrasp.graspSmp.at(j+1);
        tmpGrasp.graspSmp.at(j+1) = tmp_smp;

        tmp_dist = tmpGrasp.distance.at(j);
        tmpGrasp.distance.at(j) = tmpGrasp.distance.at(j+1);
        tmpGrasp.distance.at(j+1) = tmp_dist;
      }
    }
  }

  cout << "Founded " << tmpGrasp.graspSmp.size() << " valid grasps" << endl;

  cout << "Ordered by distance: " << endl;

  for (unsigned i = 0; i < tmpGrasp.graspSmp.size(); i++){
    cout << "Grasp sample " << i << ": ";
    for (unsigned j = 0; j < _dim; j++){
      cout << tmpGrasp.graspSmp.at(i).at(j) << " ";
    }
    cout << endl << "Distance: " << tmpGrasp.distance.at(i) << endl;
  }

  graspInfo.push_back(tmpGrasp);

  return true;
}

// Function that return a composite plan to remove all the Goals in the scene
bool Application::solveProblem( unsigned Goal ){

  bool _solved = false;
  bool sampleschanged = false;
  Solution solTmp;

  // Search for possible solutions for every grasp
  unsigned itSol = 0;
  while(!_solved){

    Sample* init = new Sample (_dim);
    init->setCoords( init_sample );

    //ToDo: Change init_sample when a robot is moving

    if (!LoadedSamples){
      _samples->clear();
    }

    Sample* smp;

    // Set initial sample

    cout << "Index of sample init: " << _samples->indexOf( init ) << endl;
    if ( _samples->indexOf( init ) == _samples->getSize()){
      _samples->add( init );

      cout << "Sample: ";
      for (unsigned s = 0; s < init->getCoords().size(); s++){
        cout << init->getCoords().at(s) << " ";
      }
      cout << endl;

      sampleschanged = true;
    }

    _planner->setInitSamp( init );

    cout << "Init sample to planning: ";
    for (unsigned i = 0; i<init->getCoords().size();i++){
            cout << init->getCoords().at(i) << " ";
    }
    cout << endl;

    //for (unsigned itSol = 0; itSol < graspInfo.graspSmp.size(); itSol++){

    // Set goal sample from grasp information
    vector<KthReal> goal( tmpGrasp.graspSmp.at( itSol ) );
    smp = new Sample(_dim);
    smp->setCoords( goal );

    cout << "Index of sample goal: " << _samples->indexOf( smp ) << endl;
    if ( _samples->indexOf( smp ) == _samples->getSize() ){
      _samples->add( smp );

      cout << "Sample: ";
      for (unsigned s = 0; s < smp->getCoords().size(); s++){
        cout << smp->getCoords().at(s) << " ";
      }
      cout << endl;

      sampleschanged = true;
    }

    _planner->setGoalSamp( smp );

    cout << "Goal sample to planning: ";
    for (unsigned i = 0; i<smp->getCoords().size();i++){
          cout << smp->getCoords().at(i) << " ";
    }
    cout << endl;

    // If exist a solution
    if(_planner->solveAndInherit()){

      // Take the simulation path
      solTmp.SimPath.resize( _planner->getSimulationPath()->size() );

      // For every sample on simulation path
      for (unsigned i = 0; i < _planner->getSimulationPath()->size(); i++){
        // Take every dof
        solTmp.SimPath.at( i ).resize( _dim );
        for (unsigned j = 0; j < _dim; j++){
          solTmp.SimPath.at( i ).at( j ) = _planner->getSimulationPath()->at( i )->getCoords().at( j );
        }
      }// endfor every sample

      _solved = true;
      cout << "*************************************** " << itSol << endl;

      // Copy the founded solution
      SolutionsInfo.push_back( solTmp );
    } //endif solveAndInherit()
    else{

      cout << "Plan without solution, re-planning for another grasp pose" << endl;

      itSol++;
      if (itSol == tmpGrasp.graspSmp.size()){
        break;
      }

    }

  //}// endfor Solution for every grasp
  }// while (!_solve)

  if (!_solved){
    // Is not possible take the goal
    return false;

  }

  cout << "Number of founded solutions: " << SolutionsInfo.size() << endl;

  cout << "Trajectory with: " << SolutionsInfo.at(0).SimPath.size() << " positions" << endl;

  if (sampleschanged){
    _planner->saveData(filepath);
    cout << "Saving Data file in (Solve problem): " << filepath << endl;
    LoadedSamples = true;
  }

  return true;
}

bool Application::SrvSetForbidden(kautham_ros::Forbidden::Request  &req,
                                     kautham_ros::Forbidden::Response &res){

  ROS_INFO("SrvSeForbidden launched");

//  for (unsigned i = 0; i < req.forbiddens.size(); i++){
//      bool insert = true;
//      for (unsigned j = 0; j < _problem->wSpace()->_forbiddenObstacles.size(); j++){
//              if (_problem->wSpace()->_forbiddenObstacles.at(j) == req.forbiddens.at( i )){
//                      insert = false;
//              }
//      }
//
//      if (insert)
//              _problem->wSpace()->_forbiddenObstacles.push_back(req.forbiddens.at( i ));
//  }

  return true;
}

bool  Application::SrvSolveProblem( kautham_ros::SolveProblem::Request &req,
                                       kautham_ros::SolveProblem::Response &res){

  ROS_INFO("SrvSolveProblem launched for goal %d", req.Goal);

  testGrasp( req.Goal );

  if (solveProblem( req.Goal )){
    res.status = true;
  }
  else{
    res.status = false;
    return false;
  }

  cout << "Soluciones encontradas: " << SolutionsInfo.size() << endl;

  _points.resize( SolutionsInfo.at( 0 ).SimPath.size() );

  for (unsigned i = 0; i < SolutionsInfo.at( 0 ).SimPath.size(); i++){
    _points.at(i).positions.resize( _dim );
    for (unsigned j = 0; j < _dim; j++){
      _points.at( i ).positions.at( j ) = SolutionsInfo.at( 0 ).SimPath.at( i ).at( j );
    }
  }

  res.SimPlan.points = _points;

  return true;
}

bool Application::SrvAttachObject( kautham_ros::AttObj::Request  &req,
                                      kautham_ros::AttObj::Response &res ){

  ROS_INFO("SrvAttachObject launched");

  Obstacle* Obst = _problem->wSpace()->getObstacle( req.Obj );

  cout << "Obstacle attached " << Obst->getName() << endl;

  _problem->wSpace()->getRobot(0)->attachObject( Obst, _problem->wSpace()->getRobot(0)->getLink( 7 )->getName() );

  return true;
}

bool Application::SrvDetachObject( kautham_ros::DetObj::Request  &req,
                                      kautham_ros::DetObj::Response &res ){

  ROS_INFO("SrvDetachObject launched");

  _problem->wSpace()->getRobot(req.Robot)->detachObject( _problem->wSpace()->getRobot(0)->getLink( 7 )->getName() );

  return true;
}

bool Application::SrvSaveData( kautham_ros::SaveData::Request  &req,
                                  kautham_ros::SaveData::Response &res ){

  ROS_INFO("SrvSaveData launched");

  if (_planner->saveData(req.problem.data))
    res.status = 1;
  else
    res.status = 0;

  return true;
}

bool Application::SrvLoadData( kautham_ros::LoadData::Request  &req,
                                  kautham_ros::LoadData::Response &res ){

  ROS_INFO("SrvLoadData launched");

  filepath = req.problem.data;

  if (_planner->loadData(filepath)){
    LoadedSamples = true;
    res.status = 1;
  }
  else
    res.status = 0;

  return true;
}
